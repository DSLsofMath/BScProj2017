% CREATED BY DAVID FRISK, 2016

\chapter{Teori}

\section{Domänspecifika språk}
\begin{draft}
  Ett domänspecifikt programmeringsspråk är ett språk som är avgränsat till ett
  specifikt domän. Detta domän kan ta många former, det kan vara ett språk för
  att formatera text på en hemsida (HTML), det kan vara ett språk för att
  interagera med en databas (SQL), ett språk för ett beskriva hur karaktärer ser
  ut (typsnitt). Användningsområden för dessa språk är väldigt smala men
  detta smala fokus gör det möjligt att utveckla ett rikt och lättanvändligt
  språk för just detta område. 

  Motsatsen till ett domänspecifikt språk är ett generellt språk (C, Java,
  Python) som är turingkompletta, vilket betyder att det kan uttrycka alla
  beräkningsbara problem i dem och även lösa dem givet tillräckligt med tid och
  minnestillgångar.\todo{referns} Begränsningen med dessa generella språk är just deras egen
  generaliserbarhet, eftersom de har stöd för alla typer av beräkningar så blir
  både läsbarheten och användarvänligheten lidande.
  
  Ett domänspecifikt språk kan antingen implementeras som ett fristående språk
  eller bäddas in i ett redan existerande språk. De domänspecifika språk som
  utvecklats inom detta projekt är inbäddade i språket \textit{Haskell}.
\end{draft}

\begin{binge}
VARFÖR BLIR DET ENKLARE? 
\end{binge}

\section{Haskell och funktionell programmering}

\begin{draft}
  Haskell är ett funktionellt programmeringsspråk som lämpar sig bra för att
  implementera ett domänspecifikt språk i. Anledningen till detta är den lätthet
  som man kan skapa nya datatyper och klasser för att representera grundstenarna
  i det nya språk, och även dess mönstermatchning som gör det möjligt att på
  enkelt sätt bryta isär komplexa datatyper för evaluering.
\end{draft}

\section{Syntaxträd och deras evaluering}

\textbf{???Osäker på om detta avsnitt är nödvändigt???}



Ett typexempel på ett domänspecifkt språk är ett syntaxträd för algebraisk uttryck, här kodat i Haskell.

\begin{figure}
  \begin{lstlisting}
  data Expr = Expr :+: Expr
            | Expr :*: Expr
            | Const Double
            | VarX

  exempel = (Const 7.0 :+: VarX) :*: ((VarX :+: Const 10.0)
            :*: VarX)
  \end{lstlisting}
  \caption{Bild!?}
  \label{fig:syntax_exempel}
\end{figure}

I detta exempel visar hur uttrycket $(7+x)*((x+10)*x)$ kodas.

Ha med en bild på detta.

!!!Plus förklaring om evaluering!


\section{Fysik vi behandlar och Fysik för ingenjörer}

\begin{draft}
  \emph{Fysik för ingenjörer} är en obligatorisk kurs för studenterna på det
  datatekniska programmet. Kursen täcker grundläggande fysikområden såsom
  mekanik, termodynamik och vågrörelselära. Det ingår även en del tillämpad
  matematik såsom vektorer och differentialkalkyl. Dessa områden ämnas att
  täckas in av de domänspecifika språken och det tillhörande läromaterialet.
\end{draft}

\section{Hemsidan}
\todo{Ha beskrivning av individuella teknologier}
\begin{draft}
  Programfilerna har skrivits i ett språk som kallas \textit{Literate Kaskell}
  som kombinerar vanlig Haskell-kod med brödtext till något som kan tolkas av en
  kompilator som två separata saker. \textit{Pandoc} är ett program som används
  för att generera html-filer med läromaterialet som är den slutgiltiga produkt
  som finns tillgänglig på hemsidan.
\end{draft}

\section{Litterat programmering och Literate Haskell}
\label{sec:lhs}

Litterat programmering (engelska \textit{literate programming}) är ett alternativt sätt att programmera som introducerats av Donald Knuth.\cite{knuth} Istället för att skriva ett program för en dator, skriver man ett program som ska läsas av människor. Det visar sig på följande två sätt.

Det en sättet är att jämfört med traditionella program får dokumentationen en ökad betydelse. I traditionella program är programkoden den viktiga delen. I litterata program däremot är dokumentationen minst lika viktig. Den anänds till att förklara koden, sätta den i relationen till andra delar och så vidare. Detta jämnbördiga förhållande syns konkret genom att titta på hur källkoden är skriven i ett literat program. Det kan till exempel se ut som i figur \ref{fig:litterate_haskell_exempel} där man ser att källkod och text för människor är sammanvävda på ett jämnbördigt sätt, där den ena inte är viktigare än den andra. 

\begin{figure}[H]
  \begin{lstlisting}[language={}]
How does all this tie together? First the type is decided, for instance

< type ExampleType = Quantity T.Length Double

then a value of that type is created

< exampleValue :: ExampleType
< exampleValue = Quantity V.length 5.3

Note that the Quantity data type has both value-level and type-level dimensions. As previosuly mentioned, value-level in order to print prettily and type-level to only permit legal operations.
  \end{lstlisting}
  \caption{Ett exempel på hur en källfil till litterat programmering kan se ut. Exemplet är Litterate Haskell. Rader som börjar med \texttt{<} markerar att det är progamkod, medan rader utan markerar att det är text för människor.}
  \label{fig:litterate_haskell_exempel}
\end{figure}

Det andra sättet ett litterat program skiljer sig åt är ordningen progamkod står i. Traditionellt används top-down eller bottom-up. Dessa tillvägagånssätt står i kontrast till den som används i litterat programmering, där man betraktar ett program som ett nät av många delar som hänger ihop, utan att de nödvändigvis har en övergripande hierariki som de tradionella metoderna bygger på. Detta uttnyttjas genom att då presentera progamkoden i den ordning som är lättast att förstå för den mänskliga läsaren.

Litterate Haskell är literat programmering för Haskell.\cite{litterate_haskell} Att progammera i Litterate Haskell går till på samma sätt som vanlig Haskell, med skillndaden att programkod och text vävs ihop i en och samma fil. Det kan se ut som i figur \ref{fig:litterate_haskell_exempel}. Filen, med tillägget \texttt{.lhs}, går att använda direkt med Haskell-kompilatorn GHC. All text ignoreras och programkoden behandlas som om den tillhörde en vanlig Haskell-fil. \texttt{.lhs}-filen kan också kompileras till material avsett för mäniskor. Det finns flera verktyg som gör det men det som används i detta projekt är \textit{Pandoc}\cite{pandoc}. Med \textit{Pandoc} kan texten märkas up med både \texttt{markdown} (används i projektet) och \texttt{Latex}. Det går att exportera till bland annat HTML och PDF.

\section{ARCS/didaktik}
\label{sec:arcs}

\begin{binge}

Lärande Skola Bildning - kap 5 lärandeteorier

Knyta an materialets undervisningspotential till lärandeteorier.

Vygotskij - Sociokulturella lärandet (ex parprogrammering + diskussion emellan individer)

Jean Piaget - Kognitivismen (lära sig A, B, A + B -> C, alternativt att eleven utmanas med något den trodde var sant, och tvingas omformulera en lösning som stödjer den presenterade situationen).

Skinner - Behaviorism (ex glada tomater vs wall of text? Det är väll egentligen detta som hindrar läsare att läsa en "tråkig, tung svårläst text")
Vi väver in det som elever inte förknippar med tunga texter -> färre flyktförsök.

\iffalse
Skulle vilja hitta stöd för:
Bara något som olika bakgrunder skulle kunna ge en inbillning av miljöombyte, vilket minskar den monotona dimensionen, och i sig förhindrar hjärnans anti-"get-stuck-on-a-thought-and-die".
\fi

\end{binge}







