<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Learn You a Physics for Great Good!</title>
    <link rel="stylesheet" type="text/css" href="../style.css">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.2/MathJax.js?config=TeX-AMS_CHTML-full" type="text/javascript"></script>
  </head>

  <body>
    <header>
      <a href="../index.html"><h1>Learn You a <span class="physics">Physics</span> for Great Good!</h1></a>
      <h1>&gt;&gt;&gt; WORK IN PROGRESS &lt;&lt;&lt;</h1>
      <h2>Calculus / Integral calculus</h2>
      <nav>
	<span>[src: <a href="https://github.com/DSLsofMath/BScProj2018/blob/master/Physics/src/Calculus/IntegralCalc.lhs">Calculus/IntegralCalc.lhs</a>]</span>
        <span>Previous: <a href="../Calculus/Differential calculus.html">Differential calculus</a></span>
        <a href="../index.html">Table of contents</a>
        <span>Next: <a href="../Calculus/Visualization.html">Visualization</a></span>
      </nav>
    </header>

    <main>
      <div class="sourceCode"><pre class="sourceCode literate haskell"><code class="sourceCode haskell"><span class="kw">module</span> <span class="dt">Calculus.IntegralCalc</span> (integrateApprox, integrate, eval) <span class="kw">where</span>

<span class="kw">import </span><span class="dt">Calculus.FunExpr</span>
<span class="kw">import </span><span class="dt">Calculus.DifferentialCalc</span></code></pre></div>
<h1 id="integrals---an-integral-part-of-calculus">Integrals - An integral part of calculus</h1>
<p><em>Integrals</em> are functions used to describe area, volume, and accumulation in general. The operation of integration is the second fundamental operation of calculus, and the inverse of differentiation. Whereas derivatives are used to describe the rate of change in an instant, integrals are used to describe the accumulation of value over time.</p>
<p>Recall how we used derivatives before. If we know the distance traveled of a car and the time it took, we can use differentiation to calculate the velocity. Similarly but reversly, if we know the velocity of the car and the time it travels for, we can use integration to calculate the distance traveled.</p>
<p><span class="math display">\[ x_{traveled} = \int_{t_0}^{t_1} v(t) dt \]</span>.</p>
<p>Ok, let's dive into this! We need to grok the syntax and find a rigorous, modelable definition of what <em>exactly</em> an integral is. We ask our kind friend Wikipedia for help. From the entry on <em>Integral</em>:</p>
<blockquote>
<p>Given a function <span class="math inline">\(f\)</span> of a real variable <span class="math inline">\(x\)</span> and an interval <span class="math inline">\([a, b]\)</span> of the real line, the definite integral</p>
<p><span class="math display">\[\int_a^b f(x) dx\]</span></p>
<div class="figure">
<img src="https://upload.wikimedia.org/wikipedia/commons/9/9f/Integral_example.svg" alt="A definite integral of a function can be represented as the signed area of the region bounded by its graph. (C) KSmrq" class="float-img-left img-border" />
<p class="caption">A definite integral of a function can be represented as the signed area of the region bounded by its graph. (C) KSmrq</p>
</div>
<p>is defined informally as the signed area of the region in the <span class="math inline">\(xy\)</span>-plane that is bounded by the graph of <span class="math inline">\(f\)</span>, the <span class="math inline">\(x\)</span>-axis and the vertical lines <span class="math inline">\(x = a\)</span> and <span class="math inline">\(x = b\)</span>. The area above the <span class="math inline">\(x\)</span>-axis adds to the total and that below the <span class="math inline">\(x\)</span>-axis subtracts from the total.</p>
<p>Roughly speaking, the operation of integration is the reverse of differentiation. For this reason, the term integral may also refer to the related notion of the antiderivative, a function <span class="math inline">\(F\)</span> whose derivative is the given function <span class="math inline">\(f\)</span>. In this case, it is called an indefinite integral and is written:</p>
<p><span class="math display">\[F(x) = \int f(x) dx\]</span></p>
</blockquote>
<p>Ok, so first of all: confusion. Apparently there are two different kinds of integrals, <em>definite integrals</em> and <em>indefinite integrals</em>?</p>
<p>Let's start with defining <em>indefinite</em> integrals. <em>Wikipedia - Antiderivative</em> tells us that the <em>indefinite</em> integral, also known as the <em>antiderivative</em>, of a function <span class="math inline">\(f\)</span> is equal to a differentiable function <span class="math inline">\(F\)</span> such that <span class="math inline">\(D(F) = f\)</span>. It further tells us that the process of finding the antiderivative is called <em>antidifferentiation</em> or <em>indefinite integration</em>.</p>
<p>The same article then brings further clarification</p>
<blockquote>
<p>Antiderivatives are related to definite integrals through the fundamental theorem of calculus: the definite integral of a function over an interval is equal to the difference between the values of an antiderivative evaluated at the endpoints of the interval.</p>
</blockquote>
<p>So indefinite integrals are the inverse of derivatives, and definite integrals are just the application of an indefinite integral to an interval. If we look back at the syntax used, this makes sense. <span class="math inline">\(\int f(x) dx\)</span> is the indefinite integral. A function not applied to anything. <span class="math inline">\(\int_a^b f(x) dx\)</span> is the definite integral. The difference of the indefinite integral being applied to the endpoints of the interval <span class="math inline">\([a,b]\)</span>.</p>
<p>To simplify a bit, we see that just as with derivatives the <span class="math inline">\(x\)</span>'s everywhere are just there to confuse us, so we remove them.</p>
<p><span class="math display">\[\int f(x) dx\]</span></p>
<p>should really just be</p>
<p><span class="math display">\[\int f\]</span>.</p>
<div class="figure">
<img src="integral.png" title="A snaky integral" class="float-img-right" />

</div>
<p>Next, the definition of definite integrals implies that we can write</p>
<p><span class="math display">\[\int_a^b f(x) dx\]</span></p>
<p>as</p>
<p><span class="math display">\[(\int f)[b] - (\int f)[a]\]</span>.</p>
<p>Only one of the two kinds of integral are fit to directly model in the syntax tree of our language. As <code>FunExpr</code> represents functions, it has to be the indefinite integral, which is a function unlike the definite integral which is a real value difference.</p>
<p>A thing to note is that while we may sometimes informally speak of the indefinite integral as a single unary function like any other, it's actually a set of functions, and the meaning of <span class="math inline">\(F(x) = \int f(x) dx\)</span> is really ambiguous. The reason for this is that for some function <span class="math inline">\(f\)</span>, there is no single function <span class="math inline">\(F\)</span> such that <span class="math inline">\(D(F) = f\)</span>. A simple counterexample is</p>
<p><span class="math display">\[D(x \mapsto x + 2) = 1 \text{ and } D(x \mapsto x + 3) = 1\]</span></p>
<p>The fact that adding a constant to a function does not change the the derivative, implies that the indefinite integral of a function is really a set of functions where the constant term differs.</p>
<p><span class="math display">\[\int f = \{ F + const C | C \in \mathbb{R} \}\]</span></p>
<p>We don't want sets though. We want unary real functions (because that's our the type of our semantics!). So, we simply say that when integrating a function, the constant term must be supplied in order to nail the result down to a single function!</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell">    <span class="fu">|</span> <span class="dt">I</span> <span class="dt">RealNum</span> <span class="dt">FunExpr</span></code></pre></div>
<h1 id="actually-integrating-with-my-man-riemann">Actually integrating with my man, Riemann</h1>
<p>We've analyzed <em>what</em> an integral is, and we can tell if a function is the antiderivative of another. For example, <span class="math inline">\(x^2\)</span> is an antiderivative of <span class="math inline">\(2x\)</span> because <span class="math inline">\(D(x^2) = 2x\)</span>. But <em>how</em> do we find integrals in the first place?</p>
<p>We start our journey with a familiar name, Leibniz. He, and also but independently Newton, discovered the heart of integrals and derivatives: The <em>fundamental theorem of calculus</em>. The definitions they made were all based on infinitesimals which, as said earlier, was considered too imprecise. Later, Riemann rigorously formalized integration using limits.</p>
<p>There exist many formal definitions of integrals, and they're not all equivalent. They each deal with different cases and classes of problems, and some remain in use mostly for pedagogical purposes. The most commonly used definitions are the Riemann integrals and the Lebesgue integrals.</p>
<p>The Riemann integral was the first rigorous definition of the integral, and for many practical applications it can be evaluated by the fundamental theorem of calculus or approximated by numerical integration. However, it is a deficient definition, and is therefore unsuitable for many theoretical purposes. For such purposes, the Lebesgue integral is a better fit.</p>
<p>All that considered, we will use Riemann integrals. While they may be lacking for many purposes, they are probably more familiar to most students (they are to me!), and will be sufficient for the level we're a.</p>
<p>If we look back at the syntax of definite integrals</p>
<p><span class="math display">\[\int_a^b f(x) dx\]</span></p>
<p>the application of <span class="math inline">\(f\)</span> and the <span class="math inline">\(dx\)</span> part actually implies the definition of the Riemann integral. We can read it in english as &quot;For every infinitesimal interval of <span class="math inline">\(x\)</span>, starting at <span class="math inline">\(a\)</span> and ending at <span class="math inline">\(b\)</span>, take the value of <span class="math inline">\(f\)</span> at that x (equiv. to taking the value at any point in the infinitesimal interval), and calculate the area of the rectangle with width <span class="math inline">\(dx\)</span> and height <span class="math inline">\(f(x)\)</span>, then sum all of these parts together.&quot;.</p>
<p>As we're dealing with an infinite sum of infinitesimal parts: a limit must be involved. <span class="math inline">\(a\)</span> and <span class="math inline">\(b\)</span> are the lower and upper limits of the sum. Our iteration variable should increase with infinitesimal <span class="math inline">\(dx\)</span> each step. Each step we add the area of the rectangle with height <span class="math inline">\(f(x&#39;)\)</span>, where <span class="math inline">\(x&#39;\)</span> is any point in <span class="math inline">\([x\)</span>, <span class="math inline">\(x + dx]\)</span>. As <span class="math inline">\(x + dx\)</span> approaches <span class="math inline">\(x\)</span> when <span class="math inline">\(dx\)</span> approaches zero, <span class="math inline">\(x&#39; = lim_{dx \to 0} x + dx = x\)</span>.</p>
<p><span class="math display">\[\int_a^b f = \int_a^b f(x) dx = lim_{dx \to 0} \sum_{x = a, a + dx, a + 2dx, ...}^b A(x, dx) \text{ where } A(x, dx) = f(x) * dx\]</span></p>
<div class="figure">
<img src="https://upload.wikimedia.org/wikipedia/commons/2/2a/Riemann_sum_convergence.png" alt="Smaller dx result in better approximations. (C) KSmrq" class="float-img-right img-border" />
<p class="caption">Smaller <span class="math inline">\(dx\)</span> result in better approximations. (C) KSmrq</p>
</div>
<p>Based on this definition, we could implement a function in haskell to compute the numerical approximation of the integral by letting <span class="math inline">\(dx\)</span> be a very small, but finite, number instead of being infinitesimal. The smaller our <span class="math inline">\(dx\)</span>, the better the approximation</p>
<div class="sourceCode"><pre class="sourceCode literate haskell"><code class="sourceCode haskell">integrateApprox f dx a b <span class="fu">=</span></code></pre></div>
<p><span class="math inline">\(b\)</span> must be greater than <span class="math inline">\(a\)</span> for a definite integral to make sense, but if that's not the case, we can just flip the order of <span class="math inline">\(a\)</span> and <span class="math inline">\(b\)</span> and flip the sign of the area.</p>
<div class="sourceCode"><pre class="sourceCode literate haskell"><code class="sourceCode haskell">  <span class="kw">let</span> xs <span class="fu">=</span> takeWhile (<span class="fu">&lt;</span>b) [a <span class="fu">+</span> <span class="dv">0</span><span class="fu">*</span>dx, a <span class="fu">+</span> <span class="dv">1</span><span class="fu">*</span>dx <span class="fu">..</span>]
      area x <span class="fu">=</span> f x <span class="fu">*</span> dx
  <span class="kw">in</span> <span class="kw">if</span> b <span class="fu">&gt;=</span> a <span class="kw">then</span> sum (fmap area xs)
              <span class="kw">else</span> (<span class="fu">-</span>(integrateApprox f dx b a))</code></pre></div>
<p>For example, let's calculate the area of the right-angled triangle under <span class="math inline">\(y = x\)</span> between <span class="math inline">\(x=0\)</span> and <span class="math inline">\(x=10\)</span>. As the area of a right-angled triangle is calculated as <span class="math inline">\(A = \frac{b * h}{2}\)</span>, we expect the result of  to approach <span class="math inline">\(A = \frac{b * h}{2} = \frac{10 * 10}{2} = 50\)</span> as <span class="math inline">\(dx\)</span> gets smaller</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell">λ integrateApprox (\textbackslash x <span class="ot">-&gt;</span> x) <span class="dv">5</span>    <span class="dv">0</span> <span class="dv">10</span>
<span class="dv">25</span>
λ integrateApprox (\textbackslash x <span class="ot">-&gt;</span> x) <span class="dv">1</span>    <span class="dv">0</span> <span class="dv">10</span>
<span class="dv">45</span>
λ integrateApprox (\textbackslash x <span class="ot">-&gt;</span> x) <span class="fl">0.5</span>  <span class="dv">0</span> <span class="dv">10</span>
<span class="fl">47.5</span>
λ integrateApprox (\textbackslash x <span class="ot">-&gt;</span> x) <span class="fl">0.1</span>  <span class="dv">0</span> <span class="dv">10</span>
<span class="fl">49.50000000000013</span>
λ integrateApprox (\textbackslash x <span class="ot">-&gt;</span> x) <span class="fl">0.01</span> <span class="dv">0</span> <span class="dv">10</span>
<span class="fl">50.04999999999996</span></code></pre></div>
<p>Great, it works for numeric approximations! This can be useful at times, but not so much in our case. We want closed expressions to use when solving physics problems, regardless of whether there are computations or not!</p>
<p>To find some integrals, making simple use of the fundamental theorem of calculus, i.e. <span class="math inline">\(D(\int f) = f\)</span>, is enough. That is, we &quot;think backwards&quot;. For example, we can use this method to find the integral of <span class="math inline">\(cos\)</span>.</p>
<p>Which function derives to <span class="math inline">\(cos\)</span>? Think, think, think ... I got it! It's <span class="math inline">\(sin\)</span>, isn't it?</p>
<p><span class="math display">\[D(sin) = cos \implies \int cos = sin + const C\]</span></p>
<p>So simple! The same method can be used to find the integral of polynomials and some other simple functions. Coupeled with some integration rules for products and exponents, this can get us quite far! But what if we're not superhumans and haven't memorized all the tables? What if we have to do integration without a cheat sheet for, like, an exam? In situations like these we make use of the definition of the Riemann integral, like we make use of the definition of differentiation in a previous chapter. As an example, let us again integrate <span class="math inline">\(cos\)</span>, but now with this second method. Keep in mind that due to the technical limitations of Riemann integrals, not all integrals may be found this way.</p>
<p>Using the trigonometric identity of <span class="math inline">\(\lim_{x \to 0} \frac{sin x}{x} = 1\)</span> we find</p>
<span class="math display">\[\begin{align*}
\int_a^b cos \\
               &amp;\{ \text{ Riemann integral }\} \\
             = &amp;\lim_{dx \to 0} \sum_{x = a, a + dx, a + 2*dx, ...}^b cos(x) * dx \\
             = &amp;\lim_{dx \to 0} dx * \sum_{x = a, a + dx, a + 2*dx, ...}^b cos(x) \\
             = &amp;\lim_{dx \to 0} dx * (cos(a) + cos(a + dx) + cos(a + 2*dx) + ... + cos(a + \frac{b - a}{dx}*dx)) \\
               &amp;\{ \text{ Sums of cosines with arguments in arithmetic progression } \} \\
             = &amp;\lim_{dx \to 0} dx * \frac{sin(\frac{(\frac{b - a}{dx} + 1) dx}{2}) * cos(a + \frac{\frac{b - a}{dx} dx}{2})}{sin(dx/2)} \\
             = &amp;\lim_{dx \to 0} dx * \frac{sin(\frac{b - a + dx}{2}) * cos(\frac{a + b}{2})}{sin(dx/2)} \\
               &amp;\{ \text{ Trig. product-to-sum ident. } \} \\
             = &amp;\lim_{dx \to 0} dx * \frac{sin(\frac{b - a + dx}{2} + \frac{a + b}{2}) + sin(\frac{b - a + dx}{2} - \frac{a + b}{2})}{2sin(dx/2)} \\
             = &amp;\lim_{dx \to 0} dx * \frac{sin(b + dx/2) + sin(-a + dx/2)}{2sin(dx/2)} \\
             = &amp;\lim_{dx \to 0} \frac{sin(b + dx/2) + sin(-a + dx/2)}{\frac{sin(dx/2)}{dx/2}} \\
               &amp;\{ dx \to 0 \} \\
             = &amp;\frac{sin(b + 0/2) + sin(-a + 0/2)}{1} \\
             = &amp;sin(b) + sin(-a) \\
             = &amp;sin(b) - sin(a)
\end{align*}\]</span>
<p>The definition of definite integrals then give us that</p>
<p><span class="math display">\[\int_a^b cos = sin(b) - sin(a) \land \int_a^b f = F(b) - F(a) \implies F = sin\]</span></p>
<p>The antiderivative of <span class="math inline">\(cos\)</span> is <span class="math inline">\(sin\)</span> (again, as expected)!</p>
<p>Let's implement these rules as a function for symbolic (indefinite) integration of functions. We'll start with the nicer cases, and progress to the not so nice ones.</p>
<p><code>integrate</code> takes a function to symbolically integrate, and a real number that decides the vertical offset (i.e. the value of <span class="math inline">\(f(0)\)</span> / the constant term) of the function. The antiderivative with the given vertical offset is returned.</p>
<p>Important to note is that not all functions are integrable. Unlike derivatives, some antiderivatives of elementary functions simply cannot be expressed as elementary functions themselves, according to <a href="https://en.wikipedia.org/wiki/Liouville%27s_theorem_%28differential_algebra%29">Liouville's theorem</a>. Some examples include <span class="math inline">\(e^{-x^2}\)</span>, <span class="math inline">\(\frac{sin(x)}{x}\)</span>, and <span class="math inline">\(x^x\)</span>.</p>
<div class="sourceCode"><pre class="sourceCode literate haskell"><code class="sourceCode haskell"><span class="ot">integrate ::</span> <span class="dt">FunExpr</span> <span class="ot">-&gt;</span> <span class="dt">RealNum</span> <span class="ot">-&gt;</span> <span class="dt">FunExpr</span></code></pre></div>
<p>First, our elementary functions. You can prove them using the methods described above, but the easiest way to find them is to just look them up in some table of integrals (dust of that old calculus cheat sheet) or on WolframAlpha (or Wikipedia, or whatever. Up to you).</p>
<div class="sourceCode"><pre class="sourceCode literate haskell"><code class="sourceCode haskell">integrate <span class="dt">Exp</span> c <span class="fu">=</span> <span class="dt">Exp</span> <span class="fu">:+</span> <span class="dt">Const</span> c
integrate <span class="dt">Log</span> c <span class="fu">=</span> <span class="dt">Id</span> <span class="fu">:*</span> (<span class="dt">Log</span> <span class="fu">:-</span> <span class="dt">Const</span> <span class="dv">1</span>) <span class="fu">:+</span> <span class="dt">Const</span> c
integrate <span class="dt">Sin</span> c <span class="fu">=</span> <span class="dt">Const</span> <span class="dv">0</span> <span class="fu">:-</span> <span class="dt">Cos</span> <span class="fu">:+</span> <span class="dt">Const</span> c
integrate <span class="dt">Cos</span> c <span class="fu">=</span> <span class="dt">Sin</span> <span class="fu">:+</span> <span class="dt">Const</span> c
integrate <span class="dt">Asin</span> c <span class="fu">=</span>    (<span class="dt">Const</span> <span class="dv">1</span> <span class="fu">:-</span> <span class="dt">Id</span><span class="fu">:^</span>(<span class="dt">Const</span> <span class="dv">2</span>))<span class="fu">:^</span>(<span class="dt">Const</span> <span class="fl">0.5</span>)
                   <span class="fu">:+</span> <span class="dt">Id</span> <span class="fu">:*</span> <span class="dt">Asin</span>
                   <span class="fu">:+</span> <span class="dt">Const</span> c
integrate <span class="dt">Acos</span> c <span class="fu">=</span>    <span class="dt">Id</span> <span class="fu">:*</span> <span class="dt">Acos</span>
                   <span class="fu">:-</span> (<span class="dt">Const</span> <span class="dv">1</span> <span class="fu">:-</span> <span class="dt">Id</span><span class="fu">:^</span>(<span class="dt">Const</span> <span class="dv">2</span>))<span class="fu">:^</span>(<span class="dt">Const</span> <span class="fl">0.5</span>)
                   <span class="fu">:+</span> <span class="dt">Const</span> c</code></pre></div>
<p>These two good boys. Very simple as well.</p>
<div class="sourceCode"><pre class="sourceCode literate haskell"><code class="sourceCode haskell">integrate <span class="dt">Id</span> c <span class="fu">=</span> <span class="dt">Id</span><span class="fu">:^</span><span class="dt">Const</span> <span class="dv">2</span> <span class="fu">:/</span> <span class="dt">Const</span> <span class="dv">2</span> <span class="fu">:+</span> <span class="dt">Const</span> c
integrate (<span class="dt">Const</span> d) c <span class="fu">=</span> <span class="dt">Const</span> d <span class="fu">:*</span> <span class="dt">Id</span> <span class="fu">:+</span> <span class="dt">Const</span> c</code></pre></div>
<p>Addition and subtraction is trivial. Just use the backwards method and compare to how sums and differences are differentiated.</p>
<div class="sourceCode"><pre class="sourceCode literate haskell"><code class="sourceCode haskell">integrate (f <span class="fu">:+</span> g) c <span class="fu">=</span> integrate f c <span class="fu">:+</span> integrate g <span class="dv">0</span>
integrate (f <span class="fu">:-</span> g) c <span class="fu">=</span> integrate f c <span class="fu">:-</span> integrate g <span class="dv">0</span></code></pre></div>
<p>Delta is easy. Just expand it to the difference that it is, and integrate.</p>
<div class="sourceCode"><pre class="sourceCode literate haskell"><code class="sourceCode haskell">integrate (<span class="dt">Delta</span> h f) c <span class="fu">=</span> integrate (f <span class="fu">:.</span> (<span class="dt">Id</span> <span class="fu">:+</span> <span class="dt">Const</span> h) <span class="fu">:-</span> f) c</code></pre></div>
<p>A derivative? That's trivial, the integration and differentiation cancel each other, right? Nope, not so simple! We have to make sure that the constant coefficient is equal to <code>c</code>, which it might not be if we just cancel the operations and add the <code>c</code>. The simplest way to solve this is to evaluate the function at <span class="math inline">\(x=0\)</span>, and check the value. We then add a term that corrects the function such that <span class="math inline">\(I(D(f), c)[0] = c\)</span>. As we haven't implemented an evaluator yet, you can leave this &quot;incorrect&quot; for now, and fix it later!</p>
<div class="sourceCode"><pre class="sourceCode literate haskell"><code class="sourceCode haskell">integrate (<span class="dt">D</span> f) c <span class="fu">=</span> f <span class="fu">:+</span> <span class="dt">Const</span> (c <span class="fu">-</span> (eval f) <span class="dv">0</span>) <span class="co">-- Correct, but requires `eval`</span>
<span class="co">-- integrate (D f) c = f -- Incorrect (unless we don&#39;t care about `c`)</span></code></pre></div>
<p>Integrating an integral? Just integrate the integral!</p>
<div class="sourceCode"><pre class="sourceCode literate haskell"><code class="sourceCode haskell">integrate (<span class="dt">I</span> d f) c <span class="fu">=</span> integrate (integrate f d) c </code></pre></div>
<p>Aaaaaand now it starts to get complicated.</p>
<p>There exists a great product rule in the case of differentiation, but not for integration. There just isn't any nice way to integrate a product that always works! The integration rule that's most analogous to the product rule for differentiation, is integration by parts:</p>
<p><span class="math display">\[ \int f(x) g(x) dx = f(x) G(x) - \int f&#39;(x) g(x) dx \]</span></p>
<p>Hmm, this doesn't look quite as helpful as the differentiation product rule, does it? We want this rule to give us an expression of simpler and/or fewer integrals, and it may indeed do so. For example, the integration of the product <span class="math inline">\(x * e^x\)</span> is a great examples of a case where it works well:</p>
<p><span class="math display">\[ \int x e^x dx = x e^x - \int 1 e^x dx = x e^x - e^x = e^x (x - 1) \]</span></p>
<p>Now THAT is a simplification. However, just by flipping the order of the expressions, we get a case where the integration by parts rule only makes things worse:</p>
<span class="math display">\[\begin{align*}
\int e^x x dx = &amp;e^x x^2 - \int e^x x dx \\
              = &amp;e^x x^2 - (e^x x^2 - \int e^x x dx) \\
              = &amp;e^x x^2 - (e^x x^2 - (e^x x^2 - \int e^x x dx)) \\
              = &amp;...
\end{align*}\]</span>
<p>Oh no, it's an infinite recursion with successive increase in complexity! Sadly, there's no good way around it. By using heuristics, we could construct a complicated algorithm that guesses the best order of factors in a product when integrating, but that's <em>way</em> out of scope for this book.</p>
<p>Further, as a consequence of Liouville's theorem, the integration by parts rule is simply not defined in the case of <span class="math inline">\(g(x)\)</span> not being integrable to <span class="math inline">\(G(x)\)</span>. And so, as there exists no definitely good way to do it, we're forced to settle for a solution that works sometimes but not always. We'll define the integration of a product to use integration by parts, but before integrating we'll simplify the expression in the hopes that it will become better suited for integration.</p>
<div class="sourceCode"><pre class="sourceCode literate haskell"><code class="sourceCode haskell">integrate (f <span class="fu">:*</span> g) c <span class="fu">=</span>
  <span class="kw">let</span> simplified <span class="fu">=</span> simplify (f <span class="fu">:*</span> g)
  <span class="kw">in</span> <span class="kw">if</span> simplified <span class="fu">==</span> f <span class="fu">:*</span> g
     <span class="kw">then</span> f <span class="fu">:*</span> integrate g <span class="dv">0</span> <span class="fu">:-</span> integrate (derive f <span class="fu">:*</span> g) <span class="dv">0</span> <span class="fu">:+</span> <span class="dt">Const</span> c
     <span class="kw">else</span> integrate simplified c</code></pre></div>
<p>The rule for quotients is very similar</p>
<div class="sourceCode"><pre class="sourceCode literate haskell"><code class="sourceCode haskell">integrate (f <span class="fu">:/</span> g) c <span class="fu">=</span>
  <span class="kw">let</span> simplified <span class="fu">=</span> simplify (f <span class="fu">:/</span> g)
  <span class="kw">in</span> <span class="kw">if</span> simplified <span class="fu">==</span> f <span class="fu">:/</span> g
     <span class="kw">then</span> <span class="kw">let</span> _F <span class="fu">=</span> integrate f <span class="dv">0</span>
          <span class="kw">in</span>    _F <span class="fu">:/</span> g
             <span class="fu">:+</span> integrate (_F <span class="fu">:*</span> (derive g <span class="fu">:/</span> (g<span class="fu">:^</span><span class="dt">Const</span> <span class="dv">2</span>))) <span class="dv">0</span>
             <span class="fu">:+</span> <span class="dt">Const</span> c
     <span class="kw">else</span> integrate simplified c</code></pre></div>
<p>There is no good rule for exponentials in general. Only for certain combinations of functions in the base and exponent is symbolic integration well defined. We'll only treat the special case of <span class="math inline">\(x^c\)</span>, which at least implies that we can use polynomials.</p>
<div class="sourceCode"><pre class="sourceCode literate haskell"><code class="sourceCode haskell">integrate (f <span class="fu">:^</span> g) c <span class="fu">=</span>
  <span class="kw">case</span> (simplify f, simplify g) <span class="kw">of</span>
    (<span class="dt">Id</span>, <span class="dt">Const</span> c) <span class="ot">-&gt;</span> <span class="dt">Id</span><span class="fu">:^</span>(<span class="dt">Const</span> (c<span class="fu">+</span><span class="dv">1</span>)) <span class="fu">:/</span> <span class="dt">Const</span> (c<span class="fu">+</span><span class="dv">1</span>)
    (_, _)        <span class="ot">-&gt;</span> error <span class="st">&quot;Can&#39;t integrate integrals like that!&quot;</span></code></pre></div>
<p><strong>Exercise.</strong> Find more rules of integrating exponentials and add to the implementation.</p>
<details> <summary><strong>Solution</strong></summary>
<div>
<p>Wikipedia has <a href="https://en.wikipedia.org/wiki/List_of_integrals_of_exponential_functions">a nice list of integrals of exponentials</a></p>
</div>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="fu">/</span>details<span class="fu">&gt;</span></code></pre></div>
<p>Integration of function composition is, simply said, somewhat complicated. The technique to use is called &quot;integration by substitution&quot;, and is something like a reverse of the chain-rule of differentiation. This method is tricky to implement, as the way humans execute this method is highly dependent on intuition and a mind for patterns. A brute-force solution would be possible to implement, but is out of scope for this book, and not really relevant to what we want to learn here. We'll leave integration of composition undefined.</p>
<p>As long as we ensure our input functions are not composed functions, <code>integrate</code> will still be well behaved.</p>
<div class="sourceCode"><pre class="sourceCode literate haskell"><code class="sourceCode haskell">integrate (f <span class="fu">:.</span> g) c
  <span class="fu">=</span> error <span class="st">&quot;Please don&#39;t try to integrate function compositions!&quot;</span></code></pre></div>
<h2 id="the-value-of-evaluation">The value of evaluation</h2>
<p>What comes after construction of function expressions? Well, using them of course!</p>
<p>One way of using a function expression is to evaluate it, and use it just as you would a normal Haskell function. To do this, we need to write an evaluator.</p>
<p>An evaluator simply takes a syntactic representation and returns the semantic value, i.e. <code>eval :: SYNTAX -&gt; SEMANTICS</code>.</p>
<p>In the case of our calculus language:</p>
<div class="sourceCode"><pre class="sourceCode literate haskell"><code class="sourceCode haskell"><span class="ot">eval ::</span> <span class="dt">FunExpr</span> <span class="ot">-&gt;</span> (<span class="dt">RealNum</span> <span class="ot">-&gt;</span> <span class="dt">RealNum</span>)</code></pre></div>
<p>To then evaluate a <code>FunExpr</code> is not very complicated. The elementary functions and the <code>Id</code> function are simply substituted for their Haskell counterparts.</p>
<div class="sourceCode"><pre class="sourceCode literate haskell"><code class="sourceCode haskell">eval <span class="dt">Exp</span> <span class="fu">=</span> exp
eval <span class="dt">Log</span> <span class="fu">=</span> log
eval <span class="dt">Sin</span> <span class="fu">=</span> sin
eval <span class="dt">Cos</span> <span class="fu">=</span> cos
eval <span class="dt">Asin</span> <span class="fu">=</span> asin
eval <span class="dt">Acos</span> <span class="fu">=</span> acos
eval <span class="dt">Id</span> <span class="fu">=</span> id</code></pre></div>
<p><code>Const</code> is evaluated according to the definition <span class="math inline">\(const(c) = x \mapsto c\)</span></p>
<div class="sourceCode"><pre class="sourceCode literate haskell"><code class="sourceCode haskell">eval (<span class="dt">Const</span> c) <span class="fu">=</span> \x <span class="ot">-&gt;</span> c</code></pre></div>
<p>How to evaluate arithmetic operations on functions may not be as obvious, but we just implement them as they were defined earlier in the chapter.</p>
<div class="sourceCode"><pre class="sourceCode literate haskell"><code class="sourceCode haskell">eval (f <span class="fu">:+</span> g) <span class="fu">=</span> \x <span class="ot">-&gt;</span> (eval f x <span class="fu">+</span> eval g x)
eval (f <span class="fu">:-</span> g) <span class="fu">=</span> \x <span class="ot">-&gt;</span> (eval f x <span class="fu">-</span> eval g x)
eval (f <span class="fu">:*</span> g) <span class="fu">=</span> \x <span class="ot">-&gt;</span> (eval f x <span class="fu">*</span> eval g x)
eval (f <span class="fu">:/</span> g) <span class="fu">=</span> \x <span class="ot">-&gt;</span> (eval f x <span class="fu">/</span> eval g x)
eval (f <span class="fu">:^</span> g) <span class="fu">=</span> \x <span class="ot">-&gt;</span> (eval f x <span class="fu">**</span> eval g x)</code></pre></div>
<p>Function composition is similarly evaluated according to the earlier definition</p>
<div class="sourceCode"><pre class="sourceCode literate haskell"><code class="sourceCode haskell">eval (f <span class="fu">:.</span> g) <span class="fu">=</span> \x <span class="ot">-&gt;</span> eval f (eval g x)</code></pre></div>
<p>Delta is just expanded to the difference that it really is</p>
<div class="sourceCode"><pre class="sourceCode literate haskell"><code class="sourceCode haskell">eval (<span class="dt">Delta</span> h f) <span class="fu">=</span> eval (f <span class="fu">:.</span> (<span class="dt">Id</span> <span class="fu">:+</span> <span class="dt">Const</span> h) <span class="fu">:-</span> f)</code></pre></div>
<p>For derivatives and integrals, we apply the symbolic operations we wrote, and then evaluate the result.</p>
<div class="sourceCode"><pre class="sourceCode literate haskell"><code class="sourceCode haskell">eval (<span class="dt">D</span> f) <span class="fu">=</span> eval (derive f)
eval (<span class="dt">I</span> c f) <span class="fu">=</span> eval (integrate f c)</code></pre></div>

    </main>

    <footer>
      <nav>
	<span>[src: <a href="https://github.com/DSLsofMath/BScProj2018/blob/master/Physics/src/Calculus/IntegralCalc.lhs">Calculus/IntegralCalc.lhs</a>]</span>
        <span>Previous: <a href="../Calculus/Differential calculus.html">Differential calculus</a></span>
        <a href="../index.html">Table of contents</a>
        <span>Next: <a href="../Calculus/Visualization.html">Visualization</a></span>
      </nav>
      © Kandidatboisen (2018), GPL
    </footer>
  </body>
</html>
