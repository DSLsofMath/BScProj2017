<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Learn You a Physics for Great Good!</title>
    <link rel="stylesheet" type="text/css" href="../style.css">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.2/MathJax.js?config=TeX-AMS_CHTML-full" type="text/javascript"></script>
  </head>

  <body>
    <header>
      <a href="../index.html"><h1>Learn You a <span class="physics">Physics</span> for Great Good!</h1></a>
      <h1>&gt;&gt;&gt; WORK IN PROGRESS &lt;&lt;&lt;</h1>
      <h2>Calculus / Function expressions</h2>
      <nav>
	<span>[src: <a href="https://github.com/DSLsofMath/BScProj2018/blob/master/Physics/src/Calculus/FunExpr.lhs">Calculus/FunExpr.lhs</a>]</span>
        <span>Previous: <a href="../Calculus/Introduction.html">Introduction</a></span>
        <a href="../index.html">Table of contents</a>
        <span>Next: <a href="../Calculus/Differential calculus.html">Differential calculus</a></span>
      </nav>
    </header>

    <main>
      <div class="sourceCode"><pre class="sourceCode literate haskell"><code class="sourceCode haskell"><span class="kw">module</span> <span class="dt">Calculus.FunExpr</span> (<span class="dt">FunExpr</span> (<span class="fu">..</span>), <span class="dt">RealNum</span>) <span class="kw">where</span>

<span class="kw">import </span><span class="dt">Test.QuickCheck</span></code></pre></div>
<h2 id="semantics-syntax-and-stuff">Semantics, syntax, and stuff</h2>
<p>What is a value in calculus? What kind of values do functions in calculus operate on and produce?</p>
<p>Let's look at derivatives to get an idea of what the semantic value of calculus is.</p>
<p><span class="math display">\[\frac{d x^2}{dx} = 2x\]</span></p>
<p><span class="math display">\[\frac{d f(x)}{dx} = f&#39;(x)\]</span></p>
<p>Hmm, these examples left me more confused than before. The differentiation function seems to take an expression as an argument, and return the derived expression, with regards to a variable. But what is an expression represented as a semantic value? It's not a number yet, the variable in the body needs to be substituted first in order for the expression to be computable. Is it some kind of function then? Well, yes it is! If we reinterpret the differentiation expressions above, it makes more sense.</p>
<p><span class="math display">\[\frac{d x^2}{dx} = 2x\]</span></p>
<p>can be written as</p>
<p><span class="math display">\[D(x^2) = 2x \text{ with regards to } x\]</span></p>
<p>which is really equivalent to</p>
<p><span class="math display">\[D(x \mapsto x^2) = x \mapsto 2x\]</span></p>
<p>or with more descriptive function names</p>
<p><span class="math display">\[D(square) = double\]</span>.</p>
<p>So the type of unary real functions seems like a great fit for a semantic value for calculus, and it is! Great! But... how do we represent a real number in Haskell? There is no <code>Real</code> type to use. Well, for simplicitys sake we can just say that a real number is basically the same as a <code>Double</code>, and it is (basically). The problem with <code>Double</code> is that it's of finite precision, so rounding errors may occur. We'll have to keep that in mind when doing calculations!</p>
<div class="sourceCode"><pre class="sourceCode literate haskell"><code class="sourceCode haskell"><span class="kw">type</span> <span class="dt">RealNum</span> <span class="fu">=</span> <span class="dt">Double</span>

<span class="co">-- The type of the semantic value of calculus is the unary real function</span>
<span class="co">--   RealNum -&gt; RealNum</span></code></pre></div>
<p>Now, to the syntax. We've concluded that real functions are really what calculus is all about, so let's model them. We create a data type <code>FunExpr</code> that will represent symbolic expressions of functions in our language.</p>
<div class="figure">
<img src="expressive.png" title="FunExpr is very expressive!" alt="FunExpr is very expressive!" class="float-img-left" />
<p class="caption"><code>FunExpr</code> is very expressive!</p>
</div>
<div class="sourceCode"><pre class="sourceCode literate haskell"><code class="sourceCode haskell"><span class="kw">data</span> <span class="dt">FunExpr</span></code></pre></div>
<p>First of all, there's the elementary functions. We can't have them all, that would get too repetitive to implement, but we'll put in all the fun ones.</p>
<div class="sourceCode"><pre class="sourceCode literate haskell"><code class="sourceCode haskell">    <span class="fu">=</span> <span class="dt">Exp</span>
    <span class="fu">|</span> <span class="dt">Log</span>
    <span class="fu">|</span> <span class="dt">Sin</span>
    <span class="fu">|</span> <span class="dt">Cos</span>
    <span class="fu">|</span> <span class="dt">Asin</span>
    <span class="fu">|</span> <span class="dt">Acos</span></code></pre></div>
<p>Then, there are the arithmetic operators. &quot;But wait&quot;, you say, &quot;Aren't arithmetic operators used to combine expressions, not functions?&quot;. I hear you, Billy, but we will do it anyways. We could make a <code>Lambda</code> constructor for &quot;VAR <span class="math inline">\(\mapsto\)</span> EXPR&quot; expressions and define the arithmetic operators for the expression type, but this would make our language much more complicated! Instead, we'll restrain ourselves to single variable expressions, which can be represented as compositions of unary functions, and define the arithmeric operators for the functions instead.</p>
<p><span class="math display">\[f \text{ OP } g = x \mapsto (f(x) \text{ OP } g(x))\]</span></p>
<div class="sourceCode"><pre class="sourceCode literate haskell"><code class="sourceCode haskell">    <span class="fu">|</span> <span class="dt">FunExpr</span> <span class="fu">:+</span> <span class="dt">FunExpr</span>
    <span class="fu">|</span> <span class="dt">FunExpr</span> <span class="fu">:-</span> <span class="dt">FunExpr</span>
    <span class="fu">|</span> <span class="dt">FunExpr</span> <span class="fu">:*</span> <span class="dt">FunExpr</span>
    <span class="fu">|</span> <span class="dt">FunExpr</span> <span class="fu">:/</span> <span class="dt">FunExpr</span>
    <span class="fu">|</span> <span class="dt">FunExpr</span> <span class="fu">:^</span> <span class="dt">FunExpr</span></code></pre></div>
<p>And then theres that single variable. As everything is a function expression, the function that best represents &quot;just a variable&quot; would be <span class="math inline">\(x \mapsto x\)</span>, which is the same as the <span class="math inline">\(id\)</span> function.</p>
<div class="sourceCode"><pre class="sourceCode literate haskell"><code class="sourceCode haskell">    <span class="fu">|</span> <span class="dt">Id</span></code></pre></div>
<p>In a similar vein, the constant function. <span class="math inline">\(const(c) = x \mapsto c\)</span></p>
<div class="sourceCode"><pre class="sourceCode literate haskell"><code class="sourceCode haskell">    <span class="fu">|</span> <span class="dt">Const</span> <span class="dt">RealNum</span></code></pre></div>
<p>Then theres function composition. If you didn't already know it, it's defined as</p>
<p><span class="math display">\[f . g = x \mapsto f(g(x))\]</span></p>
<div class="sourceCode"><pre class="sourceCode literate haskell"><code class="sourceCode haskell">    <span class="fu">|</span> <span class="dt">FunExpr</span> <span class="fu">:.</span> <span class="dt">FunExpr</span></code></pre></div>
<p>Finally, the real heroes: The functions of difference, differentiation, and integration! They will be well explored later. But for now, we define the syntax for them as</p>
<div class="sourceCode"><pre class="sourceCode literate haskell"><code class="sourceCode haskell">    <span class="fu">|</span> <span class="dt">Delta</span> <span class="dt">RealNum</span> <span class="dt">FunExpr</span>
    <span class="fu">|</span> <span class="dt">D</span> <span class="dt">FunExpr</span>
    <span class="fu">|</span> <span class="dt">I</span> <span class="dt">RealNum</span> <span class="dt">FunExpr</span></code></pre></div>
<p>Even more finally, we add a <code>deriving</code> modifier to automatically allow for equality tests between <code>FunExpr</code>s.</p>
<div class="sourceCode"><pre class="sourceCode literate haskell"><code class="sourceCode haskell">  <span class="kw">deriving</span> <span class="dt">Eq</span></code></pre></div>
<p>Nice! This syntax tree will allow us to do symbolically (at the syntax level) what we otherwise would have to do numerically (at the semantics level).</p>
<p>Before we move on, we just have to fix one thing: the operator precedence! If we don't do anything about it, this will happen</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell">ghci<span class="fu">&gt;</span> <span class="dt">Id</span> <span class="fu">:+</span> <span class="dt">Id</span> <span class="fu">:*</span> <span class="dt">Id</span> <span class="fu">==</span> (<span class="dt">Id</span> <span class="fu">:+</span> <span class="dt">Id</span>) <span class="fu">:*</span> <span class="dt">Id</span>
<span class="dt">True</span></code></pre></div>
<p>Now this is obviously wrong. <em>Plus</em> doesn't come before <em>times</em>, unless I accidentaly switched timelines in my sleep. To fix this, we have to fix the fixity. <code>infixl</code> allows us to make an operator left-associative, and set the precedence.</p>
<div class="sourceCode"><pre class="sourceCode literate haskell"><code class="sourceCode haskell"><span class="co">-- Medium precedence</span>
<span class="kw">infixl</span> <span class="dv">6</span> <span class="fu">:+</span>
<span class="kw">infixl</span> <span class="dv">6</span> <span class="fu">:-</span>
<span class="co">-- High precedence</span>
<span class="kw">infixl</span> <span class="dv">7</span> <span class="fu">:*</span>
<span class="kw">infixl</span> <span class="dv">7</span> <span class="fu">:/</span>
<span class="co">-- Higher precedence</span>
<span class="kw">infixl</span> <span class="dv">8</span> <span class="fu">:^</span>
<span class="co">-- Higherer precedence</span>
<span class="kw">infixl</span> <span class="dv">9</span> <span class="fu">:.</span></code></pre></div>
<h2 id="a-structure-with-class">A structure with class</h2>
<p>Now that we've defined the basic structure of our language, we can instantiate some useful classes. There are two in particular we care for: <code>Show</code> and <code>Arbitrary</code>.</p>
<p>Try modifying <code>FunExpr</code> to derive <code>Show</code>, so that our expressions can be printed.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell">  <span class="kw">deriving</span> <span class="dt">Eq</span>, <span class="dt">Show</span></code></pre></div>
<p>Consider now how GHCI prints out a function expression we create</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell">ghci<span class="fu">&gt;</span> carAccel <span class="fu">=</span> <span class="dt">Const</span> <span class="dv">20</span>
ghci<span class="fu">&gt;</span> carSpeed <span class="fu">=</span> <span class="dt">Const</span> <span class="dv">50</span> <span class="fu">:+</span> carAccel <span class="fu">:*</span> <span class="dt">Id</span>
ghci<span class="fu">&gt;</span> carPosition <span class="fu">=</span> <span class="dt">Const</span> <span class="dv">10</span> <span class="fu">:+</span> carSpeed <span class="fu">:*</span> <span class="dt">Id</span>
ghci<span class="fu">&gt;</span> carPosition
<span class="dt">Const</span> <span class="fl">10.0</span> <span class="fu">:+</span> (<span class="dt">Const</span> <span class="fl">50.0</span> <span class="fu">:+</span> <span class="dt">Const</span> <span class="fl">20.0</span> <span class="fu">:*</span> <span class="dt">Id</span>) <span class="fu">:*</span> <span class="dt">Id</span></code></pre></div>
<p>Well that's borderline unreadable. Further, the grokability of a printed expression is very inversely proportional to the size/complexity of the expression, as I'm sure you can imagine.</p>
<p>So if the <code>Show</code> is bad, we'll just have to make our own <code>Show</code>!</p>
<div class="sourceCode"><pre class="sourceCode literate haskell"><code class="sourceCode haskell"><span class="kw">instance</span> <span class="dt">Show</span> <span class="dt">FunExpr</span> <span class="kw">where</span>
  show <span class="dt">Exp</span> <span class="fu">=</span> <span class="st">&quot;exp&quot;</span>
  show <span class="dt">Log</span> <span class="fu">=</span> <span class="st">&quot;log&quot;</span>
  show <span class="dt">Sin</span> <span class="fu">=</span> <span class="st">&quot;sin&quot;</span>
  show <span class="dt">Cos</span> <span class="fu">=</span> <span class="st">&quot;cos&quot;</span>
  show <span class="dt">Asin</span> <span class="fu">=</span> <span class="st">&quot;asin&quot;</span>
  show <span class="dt">Acos</span> <span class="fu">=</span> <span class="st">&quot;acos&quot;</span>
  show (f <span class="fu">:+</span> g) <span class="fu">=</span> <span class="st">&quot;(&quot;</span> <span class="fu">++</span> show f <span class="fu">++</span> <span class="st">&quot; + &quot;</span> <span class="fu">++</span> show g <span class="fu">++</span> <span class="st">&quot;)&quot;</span>
  show (f <span class="fu">:-</span> g) <span class="fu">=</span> <span class="st">&quot;(&quot;</span> <span class="fu">++</span> show f <span class="fu">++</span> <span class="st">&quot; - &quot;</span> <span class="fu">++</span> show g <span class="fu">++</span> <span class="st">&quot;)&quot;</span>
  show (f <span class="fu">:*</span> g) <span class="fu">=</span> <span class="st">&quot;(&quot;</span> <span class="fu">++</span> show f <span class="fu">++</span> <span class="st">&quot; * &quot;</span> <span class="fu">++</span> show g <span class="fu">++</span> <span class="st">&quot;)&quot;</span>
  show (f <span class="fu">:/</span> g) <span class="fu">=</span> <span class="st">&quot;(&quot;</span> <span class="fu">++</span> show f <span class="fu">++</span> <span class="st">&quot; / &quot;</span> <span class="fu">++</span> show g <span class="fu">++</span> <span class="st">&quot;)&quot;</span>
  show (f <span class="fu">:^</span> g) <span class="fu">=</span> <span class="st">&quot;(&quot;</span> <span class="fu">++</span> show f <span class="fu">++</span> <span class="st">&quot;^&quot;</span> <span class="fu">++</span> show g <span class="fu">++</span> <span class="st">&quot;)&quot;</span>
  show <span class="dt">Id</span> <span class="fu">=</span> <span class="st">&quot;x&quot;</span>
  show (<span class="dt">Const</span> x) <span class="fu">=</span> showReal x
  show (f <span class="fu">:.</span> g) <span class="fu">=</span> <span class="st">&quot;(&quot;</span> <span class="fu">++</span> show f <span class="fu">++</span> <span class="st">&quot; . &quot;</span> <span class="fu">++</span> show g <span class="fu">++</span> <span class="st">&quot;)&quot;</span>
  show (<span class="dt">Delta</span> h f) <span class="fu">=</span> <span class="st">&quot;(delta_&quot;</span> <span class="fu">++</span> showReal h <span class="fu">++</span> <span class="st">&quot; &quot;</span> <span class="fu">++</span> show f <span class="fu">++</span> <span class="st">&quot;)&quot;</span>
  show (<span class="dt">D</span> f) <span class="fu">=</span> <span class="st">&quot;(D &quot;</span> <span class="fu">++</span> show f <span class="fu">++</span> <span class="st">&quot;)&quot;</span>
  show (<span class="dt">I</span> c f) <span class="fu">=</span> <span class="st">&quot;(I at &quot;</span> <span class="fu">++</span> show c <span class="fu">++</span> <span class="st">&quot; for &quot;</span> <span class="fu">++</span> show f <span class="fu">++</span> <span class="st">&quot;)&quot;</span>

showReal x <span class="fu">=</span> <span class="kw">if</span> isInt x <span class="kw">then</span> show (round x) <span class="kw">else</span> show x
  <span class="kw">where</span> isInt x <span class="fu">=</span> x <span class="fu">==</span> fromInteger (round x)</code></pre></div>
<p>Not much to explain here. It's just one way to print our syntax tree in a more readable way. What's interesting is how we can now print our expressions in a much more human friendly way!</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell">ghci<span class="fu">&gt;</span> carPosition
(<span class="dv">10</span> <span class="fu">+</span> ((<span class="dv">50</span> <span class="fu">+</span> (<span class="dv">20</span> <span class="fu">*</span> id)) <span class="fu">*</span> id))</code></pre></div>
<p>Still a bit noisy with all the parentheses, but much better!</p>
<p>Another class we need to instance for our <code>FunExpr</code> is <code>Arbitrary</code>. This class is associated with the testing library <em>QuickCheck</em>, and describes how to generate arbitrary values of a type for use when testing logical properties with <code>quickCheck</code>. For example, a property function could be formulated that states that the <code>:*</code> constructor of <code>FunExpr</code> is associative.</p>
<p>The implementation itself is not very interesting. We generate a function expression that tends to contain mostly elementary functions, arithmetic operations, and a generous dose of constants; with a light sprinkle of differences, derivatives, and integrals.</p>
<div class="sourceCode"><pre class="sourceCode literate haskell"><code class="sourceCode haskell"><span class="kw">instance</span> <span class="dt">Arbitrary</span> <span class="dt">FunExpr</span> <span class="kw">where</span>
  arbitrary <span class="fu">=</span></code></pre></div>
<p><code>frequency</code> &quot;chooses one of the given generators, with a weighted random distribution&quot;. By assigning probabilities of generating certain functions more often than others, we can restrain the growth of the generated expressions in complexity.</p>
<div class="sourceCode"><pre class="sourceCode literate haskell"><code class="sourceCode haskell">      frequency
        [ (<span class="dv">10</span>, genElementary)
        , (<span class="dv">10</span>, genBinaryOperation)
        , (<span class="dv">10</span>, return <span class="dt">Id</span>)
        , (<span class="dv">20</span>, fmap <span class="dt">Const</span> arbitrary)
        , (<span class="dv">10</span>, genBinaryApp (<span class="fu">:.</span>))
        , (<span class="dv">5</span> , genBinaryApp <span class="dt">Delta</span>)
        , (<span class="dv">5</span> , fmap <span class="dt">D</span> arbitrary)
        , (<span class="dv">5</span> , genBinaryApp <span class="dt">I</span>) ]
    <span class="kw">where</span> genElementary <span class="fu">=</span> elements [<span class="dt">Exp</span>, <span class="dt">Log</span>, <span class="dt">Sin</span>, <span class="dt">Cos</span>, <span class="dt">Asin</span>, <span class="dt">Acos</span>]
          genBinaryApp op <span class="fu">=</span> fmap (\(f, g) <span class="ot">-&gt;</span> f <span class="ot">`op`</span> g) arbitrary
          genBinaryOperation <span class="fu">=</span>     elements [(<span class="fu">:+</span>), (<span class="fu">:-</span>), (<span class="fu">:*</span>), (<span class="fu">:/</span>), (<span class="fu">:^</span>)]
                               <span class="fu">&gt;&gt;=</span> genBinaryApp</code></pre></div>

    </main>

    <footer>
      <nav>
	<span>[src: <a href="https://github.com/DSLsofMath/BScProj2018/blob/master/Physics/src/Calculus/FunExpr.lhs">Calculus/FunExpr.lhs</a>]</span>
        <span>Previous: <a href="../Calculus/Introduction.html">Introduction</a></span>
        <a href="../index.html">Table of contents</a>
        <span>Next: <a href="../Calculus/Differential calculus.html">Differential calculus</a></span>
      </nav>
      © Kandidatboisen (2018), GPL
    </footer>
  </body>
</html>
