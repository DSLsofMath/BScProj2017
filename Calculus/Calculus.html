<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Learn You a Physics for Great Good!</title>
    <link rel="stylesheet" type="text/css" href="../style.css">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.2/MathJax.js?config=TeX-AMS_CHTML-full" type="text/javascript"></script>
  </head>

  <body>
    <header>
      <a href="../index.html"><h1>Learn You a <span class="physics">Physics</span> for Great Good!</h1></a>
      <h1>&gt;&gt;&gt; WORK IN PROGRESS &lt;&lt;&lt;</h1>
      <nav>
        <span>Previous: <a href="../Vectors/Vector.html">Vector</a></span>
        <a href="../index.html">Table of contents</a>
        <span>Next: <a href="../Calculus/Syntax Tree.html">Syntax Tree</a></span>
      </nav>
    </header>

    <main>
      <h1 id="what-is-calculus">What is calculus?</h1>
<p>TODO: Move relevant stuff out of the general structures/eval to their respective sections? (differences, derivatives, integrals) Or maybe, first introduce differences et al. separately, and then tie them together in a common section of evaluation?</p>
<p>TODO: Make the text gooder in general</p>
<p>TODO: Quotes -&gt; good teaching text (especially in Integral secion)</p>
<p>TODO: Proofs/tests/verification</p>
<p>TODO: Improve DSLs a bit? I don’t like the <code>Expr</code> tree very much. Separate into <code>FunExpr</code> and <code>Expr</code>, where <code>Expr</code> is very simple?</p>
<p>TODO: Have someone critique this</p>
<p>Plain equations where all values are of the same dimension are all fine and well. The importance of being able to solve basic problems like “If Jenny has 22 meters, and Richard has 18 meters: how many meters do they have together?” cannot be understated, but they’re not especially fun!</p>
<p>“An unstoppable car has an unchanging velocity of 141.622272 km/h. How many kilometers has it droven after a day?”. To solve more interesting problems like this, we need calculus.</p>
<p>Calculus is the study of stuff that continuously change over time (or some other continuous variable). For example, a distance that changes over time is equivalent to a speed or a velocity, depending on how many dimensions you have, and a volume that changes as a length changes does not have a name, as far as I know.</p>
<p>There are two major branches of calculus, differential calculus and integral calculus. Differential calculus is all about those rates of changes and graph slopes. Differences, differentials, derivatives, and the like. Integral calculus, on the other hand, is all about accumulation and areas. Sums, integrals, and such.</p>
<p>In this chapter we’ll expore the syntax of diffences, the problem with differentials, symbolic differentiation, numeric and symbolic integration, and some applied problem solving.</p>
<h2 id="boring-boilerplate">Boring boilerplate</h2>
<p>Firstly, let’s get the boring stuff out of the way. This is our module!</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode literate haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb1-1" data-line-number="1"><span class="kw">module</span> <span class="dt">Calculus.Calculus</span> <span class="kw">where</span></a></code></pre></div>
<p>Important imports!</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode literate haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb2-1" data-line-number="1"><span class="kw">import</span> <span class="dt">Data.Maybe</span></a>
<a class="sourceLine" id="cb2-2" data-line-number="2"><span class="kw">import</span> <span class="dt">Data.List</span></a>
<a class="sourceLine" id="cb2-3" data-line-number="3"><span class="kw">import</span> <span class="dt">Data.String</span></a>
<a class="sourceLine" id="cb2-4" data-line-number="4"><span class="kw">import</span> <span class="dt">Control.Exception</span></a>
<a class="sourceLine" id="cb2-5" data-line-number="5"><span class="kw">import</span> <span class="dt">Test.QuickCheck</span></a></code></pre></div>
<p>This import is especially interesting. <a href="https://github.com/DSLsofMath/Hatlab">Hatlab</a> is a very simple graph plotting library that we can use to draw pretty graphs of our functions, derivatives, and integrals later!</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode literate haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb3-1" data-line-number="1"><span class="kw">import</span> <span class="dt">Hatlab.Plot</span></a></code></pre></div>
<h2 id="semantics-syntax-and-lambda-calculus">Semantics, syntax, and lambda calculus</h2>
<p>What is a value in calculus? What kind of values do functions in calculus operate on and produce?</p>
<p>Let’s look at derivatives to get an idea of what the semantic value of calculus is.</p>
<p><span class="math display">\[\frac{d x^2}{dx} = 2x\]</span></p>
<p><span class="math display">\[\frac{d f(x)}{dx} = f&#39;(x)\]</span></p>
<p>Hmm, these examples left me more confused than before. The differentiation function seems to take an expression as an argument, and return the derived expression, with regards to a variable. But what is an expression represented as a semantic value? It’s not a number yet, the variable in the body needs to be substituted first in order for the expression to be computable. Is it some kind of function then? Well, yes it is! If we reinterpret the differentiation expressions above, it makes more sense.</p>
<p><span class="math display">\[\frac{d x^2}{dx} = 2x\]</span></p>
<p>can be written as</p>
<p><span class="math display">\[D(x^2) = 2x \text{ with regards to } x\]</span></p>
<p>which is really equivalent to</p>
<p><span class="math display">\[D(x \mapsto x^2) = x \mapsto 2x\]</span></p>
<p>or</p>
<p><span class="math display">\[D(square) = double\]</span>.</p>
<p>So the type of unary real functions seems like a great fit for a semantic value for calculus, and it is! Great! But… how do we represent a real number in Haskell? There is no <code>Real</code> type to use. Well, for simplicitys sake we can just say that a real number is basically the same as a <code>Double</code>, and it is (basically). The problem with <code>Double</code> is that it’s of finite precision, so rounding errors may occur. We’ll have to keep that in mind when doing calculations!</p>
<div class="sourceCode" id="cb4"><pre class="sourceCode literate haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb4-1" data-line-number="1"><span class="kw">type</span> <span class="dt">RealNum</span> <span class="fu">=</span> <span class="dt">Double</span></a>
<a class="sourceLine" id="cb4-2" data-line-number="2"></a>
<a class="sourceLine" id="cb4-3" data-line-number="3"><span class="co">-- The type of the semantic value of calculus is the unary real function</span></a>
<a class="sourceLine" id="cb4-4" data-line-number="4"><span class="co">--   RealNum -&gt; RealNum</span></a></code></pre></div>
<p>Now, to the syntax. We’ve concluded that real functions are really what calculus is all about, so let’s model them.</p>
<div class="sourceCode" id="cb5"><pre class="sourceCode literate haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb5-1" data-line-number="1"><span class="kw">data</span> <span class="dt">FunExpr</span></a></code></pre></div>
<p>First of all, there’s the elementary functions. We can’t have them all, that would get too repetitive to implement, but we’ll put in all the fun ones.</p>
<div class="sourceCode" id="cb6"><pre class="sourceCode literate haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb6-1" data-line-number="1">    <span class="fu">=</span> <span class="dt">Exp</span></a>
<a class="sourceLine" id="cb6-2" data-line-number="2">    <span class="fu">|</span> <span class="dt">Log</span></a>
<a class="sourceLine" id="cb6-3" data-line-number="3">    <span class="fu">|</span> <span class="dt">Sin</span></a>
<a class="sourceLine" id="cb6-4" data-line-number="4">    <span class="fu">|</span> <span class="dt">Cos</span></a>
<a class="sourceLine" id="cb6-5" data-line-number="5">    <span class="fu">|</span> <span class="dt">Asin</span></a>
<a class="sourceLine" id="cb6-6" data-line-number="6">    <span class="fu">|</span> <span class="dt">Acos</span></a></code></pre></div>
<p>Then, there are the arithmetic operators. “But wait”, you say, “Aren’t arithmetic operators used to combine expressions, not functions?”. I hear you, Billy, but we will do it anyways. We could make a <code>Lambda</code> constructor for “VAR <span class="math inline">\(\mapsto\)</span> EXPR” expressions and define the arithmetic operators for the expression type, but this would make our language much more complicated! Instead, we’ll restrain ourselves to single variable expressions, which can be represented as compositions of unary functions, and define the arithmeric operators for the functions instead.</p>
<p><span class="math display">\[f \text{ OP } g = x \mapsto (f(x) \text{ OP } g(x))\]</span></p>
<div class="sourceCode" id="cb7"><pre class="sourceCode literate haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb7-1" data-line-number="1">    <span class="fu">|</span> <span class="dt">FunExpr</span> <span class="fu">:+</span> <span class="dt">FunExpr</span></a>
<a class="sourceLine" id="cb7-2" data-line-number="2">    <span class="fu">|</span> <span class="dt">FunExpr</span> <span class="fu">:-</span> <span class="dt">FunExpr</span></a>
<a class="sourceLine" id="cb7-3" data-line-number="3">    <span class="fu">|</span> <span class="dt">FunExpr</span> <span class="fu">:*</span> <span class="dt">FunExpr</span></a>
<a class="sourceLine" id="cb7-4" data-line-number="4">    <span class="fu">|</span> <span class="dt">FunExpr</span> <span class="fu">:/</span> <span class="dt">FunExpr</span></a>
<a class="sourceLine" id="cb7-5" data-line-number="5">    <span class="fu">|</span> <span class="dt">FunExpr</span> <span class="fu">:^</span> <span class="dt">FunExpr</span></a></code></pre></div>
<p>And then theres that single variable. As everything is a function expression, the function that best represents “just a variable” would be <span class="math inline">\(x \mapsto x\)</span>, which is the same as the <span class="math inline">\(id\)</span> function.</p>
<div class="sourceCode" id="cb8"><pre class="sourceCode literate haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb8-1" data-line-number="1">    <span class="fu">|</span> <span class="dt">Id</span></a></code></pre></div>
<p>In a similar vein, the constant function. <span class="math inline">\(const(c) = x \mapsto c\)</span></p>
<div class="sourceCode" id="cb9"><pre class="sourceCode literate haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb9-1" data-line-number="1">    <span class="fu">|</span> <span class="dt">Const</span> <span class="dt">RealNum</span></a></code></pre></div>
<p>Then theres function composition. If you didn’t already know it, it’s defined as</p>
<p><span class="math display">\[f . g = x \mapsto f(g(x))\]</span></p>
<div class="sourceCode" id="cb10"><pre class="sourceCode literate haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb10-1" data-line-number="1">    <span class="fu">|</span> <span class="dt">FunExpr</span> <span class="fu">:.</span> <span class="dt">FunExpr</span></a></code></pre></div>
<p>Finally, the real heroes: The functions of difference, differentiation, and integration! They will be well explored later. But for now, we define the syntax for them as</p>
<div class="sourceCode" id="cb11"><pre class="sourceCode literate haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb11-1" data-line-number="1">    <span class="fu">|</span> <span class="dt">Delta</span> <span class="dt">RealNum</span> <span class="dt">FunExpr</span></a>
<a class="sourceLine" id="cb11-2" data-line-number="2">    <span class="fu">|</span> <span class="dt">D</span> <span class="dt">FunExpr</span></a>
<a class="sourceLine" id="cb11-3" data-line-number="3">    <span class="fu">|</span> <span class="dt">I</span> <span class="dt">RealNum</span> <span class="dt">FunExpr</span></a></code></pre></div>
<p>Even more finally, we add a <code>deriving</code> modifier to automatically allow for equality tests between <code>FunExpr</code>s.</p>
<div class="sourceCode" id="cb12"><pre class="sourceCode literate haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb12-1" data-line-number="1">  <span class="kw">deriving</span> <span class="dt">Eq</span></a></code></pre></div>
<p>Nice! This syntax tree will allow us to do symbolically (at the syntax level) what we otherwise would have to do numerically (at the semantics level).</p>
<p>Before we move on, we just have to fix one thing: the operator precedence! If we don’t do anything about it, this will happen</p>
<div class="sourceCode" id="cb13"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb13-1" data-line-number="1">ghci<span class="fu">&gt;</span> <span class="dt">Id</span> <span class="fu">:+</span> <span class="dt">Id</span> <span class="fu">:*</span> <span class="dt">Id</span> <span class="fu">==</span> (<span class="dt">Id</span> <span class="fu">:+</span> <span class="dt">Id</span>) <span class="fu">:*</span> <span class="dt">Id</span></a>
<a class="sourceLine" id="cb13-2" data-line-number="2"><span class="dt">True</span></a></code></pre></div>
<p>Now this is obviously wrong. <em>Plus</em> doesn’t come before <em>times</em>, unless I accidentaly switched timelines in my sleep. To fix this, we have to fix the fixity. <code>infixl</code> allows us to make an operator left-associative, and set the precedence.</p>
<div class="sourceCode" id="cb14"><pre class="sourceCode literate haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb14-1" data-line-number="1"><span class="co">-- Medium precedence</span></a>
<a class="sourceLine" id="cb14-2" data-line-number="2"><span class="kw">infixl</span> <span class="dv">6</span> <span class="fu">:+</span></a>
<a class="sourceLine" id="cb14-3" data-line-number="3"><span class="kw">infixl</span> <span class="dv">6</span> <span class="fu">:-</span></a>
<a class="sourceLine" id="cb14-4" data-line-number="4"><span class="co">-- Higher</span></a>
<a class="sourceLine" id="cb14-5" data-line-number="5"><span class="kw">infixl</span> <span class="dv">7</span> <span class="fu">:*</span></a>
<a class="sourceLine" id="cb14-6" data-line-number="6"><span class="kw">infixl</span> <span class="dv">7</span> <span class="fu">:/</span></a>
<a class="sourceLine" id="cb14-7" data-line-number="7"><span class="co">-- Higherer</span></a>
<a class="sourceLine" id="cb14-8" data-line-number="8"><span class="kw">infixl</span> <span class="dv">8</span> <span class="fu">:^</span></a>
<a class="sourceLine" id="cb14-9" data-line-number="9"><span class="co">-- High as a kite</span></a>
<a class="sourceLine" id="cb14-10" data-line-number="10"><span class="kw">infixl</span> <span class="dv">9</span> <span class="fu">:.</span></a></code></pre></div>
<p>HEJ JOHAN! Vet inte vad du vill ha det här så lägger det bara mitt i ◕ ◡ ◕ fattas några operationer eftersom jag inte visste hur du ville hantera dem.</p>
<div class="sourceCode" id="cb15"><pre class="sourceCode literate haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb15-1" data-line-number="1"><span class="kw">instance</span> <span class="dt">Num</span> <span class="dt">FunExpr</span> <span class="kw">where</span></a>
<a class="sourceLine" id="cb15-2" data-line-number="2">  (<span class="fu">+</span>) <span class="fu">=</span> (<span class="fu">:+</span>)</a>
<a class="sourceLine" id="cb15-3" data-line-number="3">  (<span class="fu">*</span>) <span class="fu">=</span> (<span class="fu">:*</span>)</a>
<a class="sourceLine" id="cb15-4" data-line-number="4">  (<span class="fu">-</span>) <span class="fu">=</span> (<span class="fu">:-</span>)</a>
<a class="sourceLine" id="cb15-5" data-line-number="5">  fromInteger i <span class="fu">=</span> <span class="dt">Const</span> (fromInteger i)</a></code></pre></div>
<div class="sourceCode" id="cb16"><pre class="sourceCode literate haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb16-1" data-line-number="1"><span class="kw">instance</span> <span class="dt">Fractional</span> <span class="dt">FunExpr</span> <span class="kw">where</span></a>
<a class="sourceLine" id="cb16-2" data-line-number="2">  (<span class="fu">/</span>) <span class="fu">=</span> (<span class="fu">:/</span>)</a>
<a class="sourceLine" id="cb16-3" data-line-number="3">  fromRational r <span class="fu">=</span> <span class="dt">Const</span> (fromRational r)</a></code></pre></div>
<div class="sourceCode" id="cb17"><pre class="sourceCode literate haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb17-1" data-line-number="1"><span class="kw">instance</span> <span class="dt">Floating</span> <span class="dt">FunExpr</span> <span class="kw">where</span></a>
<a class="sourceLine" id="cb17-2" data-line-number="2">  pi     <span class="fu">=</span> <span class="dt">Const</span>   pi</a>
<a class="sourceLine" id="cb17-3" data-line-number="3">  exp a  <span class="fu">=</span> <span class="dt">Exp</span>  <span class="fu">:.</span> a</a>
<a class="sourceLine" id="cb17-4" data-line-number="4">  log a  <span class="fu">=</span> <span class="dt">Log</span>  <span class="fu">:.</span> a</a>
<a class="sourceLine" id="cb17-5" data-line-number="5">  sin a  <span class="fu">=</span> <span class="dt">Sin</span>  <span class="fu">:.</span> a</a>
<a class="sourceLine" id="cb17-6" data-line-number="6">  cos a  <span class="fu">=</span> <span class="dt">Cos</span>  <span class="fu">:.</span> a</a>
<a class="sourceLine" id="cb17-7" data-line-number="7">  asin a <span class="fu">=</span> <span class="dt">Asin</span> <span class="fu">:.</span> a</a>
<a class="sourceLine" id="cb17-8" data-line-number="8">  acos a <span class="fu">=</span> <span class="dt">Acos</span> <span class="fu">:.</span> a</a></code></pre></div>
<h2 id="a-structure-with-class">A structure with class</h2>
<p>Now that we’ve defined the basic structure of our language, we can instantiate some useful classes. There are two in particular we care for: <code>Show</code> and <code>Arbitrary</code>.</p>
<p>Try modifying <code>FunExpr</code> to derive <code>Show</code>, so that our expressions can be printed.</p>
<div class="sourceCode" id="cb18"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb18-1" data-line-number="1">  <span class="kw">deriving</span> <span class="dt">Eq</span>, <span class="dt">Show</span></a></code></pre></div>
<p>Consider now how GHCI prints out a function expression we create</p>
<div class="sourceCode" id="cb19"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb19-1" data-line-number="1">ghci<span class="fu">&gt;</span> carAccel <span class="fu">=</span> <span class="dt">Const</span> <span class="dv">20</span></a>
<a class="sourceLine" id="cb19-2" data-line-number="2">ghci<span class="fu">&gt;</span> carSpeed <span class="fu">=</span> <span class="dt">Const</span> <span class="dv">50</span> <span class="fu">:+</span> carAccel <span class="fu">:*</span> <span class="dt">Id</span></a>
<a class="sourceLine" id="cb19-3" data-line-number="3">ghci<span class="fu">&gt;</span> carPosition <span class="fu">=</span> <span class="dt">Const</span> <span class="dv">10</span> <span class="fu">:+</span> carSpeed <span class="fu">:*</span> <span class="dt">Id</span></a>
<a class="sourceLine" id="cb19-4" data-line-number="4">ghci<span class="fu">&gt;</span> carPosition</a>
<a class="sourceLine" id="cb19-5" data-line-number="5"><span class="dt">Const</span> <span class="fl">10.0</span> <span class="fu">:+</span> (<span class="dt">Const</span> <span class="fl">50.0</span> <span class="fu">:+</span> <span class="dt">Const</span> <span class="fl">20.0</span> <span class="fu">:*</span> <span class="dt">Id</span>) <span class="fu">:*</span> <span class="dt">Id</span></a></code></pre></div>
<p>Well that’s borderline unreadable. Further, the grokability of a printed expression is very inversely proportional to the size/complexity of the expression, as I’m sure you can imagine.</p>
<p>So if the <code>Show</code> is bad, we’ll just have to make our own <code>Show</code>!</p>
<div class="sourceCode" id="cb20"><pre class="sourceCode literate haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb20-1" data-line-number="1"><span class="kw">instance</span> <span class="dt">Show</span> <span class="dt">FunExpr</span> <span class="kw">where</span></a>
<a class="sourceLine" id="cb20-2" data-line-number="2">  show <span class="dt">Exp</span> <span class="fu">=</span> <span class="st">&quot;exp&quot;</span></a>
<a class="sourceLine" id="cb20-3" data-line-number="3">  show <span class="dt">Log</span> <span class="fu">=</span> <span class="st">&quot;log&quot;</span></a>
<a class="sourceLine" id="cb20-4" data-line-number="4">  show <span class="dt">Sin</span> <span class="fu">=</span> <span class="st">&quot;sin&quot;</span></a>
<a class="sourceLine" id="cb20-5" data-line-number="5">  show <span class="dt">Cos</span> <span class="fu">=</span> <span class="st">&quot;cos&quot;</span></a>
<a class="sourceLine" id="cb20-6" data-line-number="6">  show <span class="dt">Asin</span> <span class="fu">=</span> <span class="st">&quot;asin&quot;</span></a>
<a class="sourceLine" id="cb20-7" data-line-number="7">  show <span class="dt">Acos</span> <span class="fu">=</span> <span class="st">&quot;acos&quot;</span></a>
<a class="sourceLine" id="cb20-8" data-line-number="8">  show (f <span class="fu">:+</span> g) <span class="fu">=</span> <span class="st">&quot;(&quot;</span> <span class="fu">++</span> show f <span class="fu">++</span> <span class="st">&quot; + &quot;</span> <span class="fu">++</span> show g <span class="fu">++</span> <span class="st">&quot;)&quot;</span></a>
<a class="sourceLine" id="cb20-9" data-line-number="9">  show (f <span class="fu">:-</span> g) <span class="fu">=</span> <span class="st">&quot;(&quot;</span> <span class="fu">++</span> show f <span class="fu">++</span> <span class="st">&quot; - &quot;</span> <span class="fu">++</span> show g <span class="fu">++</span> <span class="st">&quot;)&quot;</span></a>
<a class="sourceLine" id="cb20-10" data-line-number="10">  show (f <span class="fu">:*</span> g) <span class="fu">=</span> <span class="st">&quot;(&quot;</span> <span class="fu">++</span> show f <span class="fu">++</span> <span class="st">&quot; * &quot;</span> <span class="fu">++</span> show g <span class="fu">++</span> <span class="st">&quot;)&quot;</span></a>
<a class="sourceLine" id="cb20-11" data-line-number="11">  show (f <span class="fu">:/</span> g) <span class="fu">=</span> <span class="st">&quot;(&quot;</span> <span class="fu">++</span> show f <span class="fu">++</span> <span class="st">&quot; / &quot;</span> <span class="fu">++</span> show g <span class="fu">++</span> <span class="st">&quot;)&quot;</span></a>
<a class="sourceLine" id="cb20-12" data-line-number="12">  show (f <span class="fu">:^</span> g) <span class="fu">=</span> <span class="st">&quot;(&quot;</span> <span class="fu">++</span> show f <span class="fu">++</span> <span class="st">&quot;^&quot;</span> <span class="fu">++</span> show g <span class="fu">++</span> <span class="st">&quot;)&quot;</span></a>
<a class="sourceLine" id="cb20-13" data-line-number="13">  show <span class="dt">Id</span> <span class="fu">=</span> <span class="st">&quot;id&quot;</span></a>
<a class="sourceLine" id="cb20-14" data-line-number="14">  show (<span class="dt">Const</span> x) <span class="fu">=</span> showReal x</a>
<a class="sourceLine" id="cb20-15" data-line-number="15">  show (f <span class="fu">:.</span> g) <span class="fu">=</span> <span class="st">&quot;(&quot;</span> <span class="fu">++</span> show f <span class="fu">++</span> <span class="st">&quot; . &quot;</span> <span class="fu">++</span> show g <span class="fu">++</span> <span class="st">&quot;)&quot;</span></a>
<a class="sourceLine" id="cb20-16" data-line-number="16">  show (<span class="dt">Delta</span> h f) <span class="fu">=</span> <span class="st">&quot;(delta_&quot;</span> <span class="fu">++</span> showReal h <span class="fu">++</span> <span class="st">&quot; &quot;</span> <span class="fu">++</span> show f <span class="fu">++</span> <span class="st">&quot;)&quot;</span></a>
<a class="sourceLine" id="cb20-17" data-line-number="17">  show (<span class="dt">D</span> f) <span class="fu">=</span> <span class="st">&quot;(D &quot;</span> <span class="fu">++</span> show f <span class="fu">++</span> <span class="st">&quot;)&quot;</span></a>
<a class="sourceLine" id="cb20-18" data-line-number="18">  show (<span class="dt">I</span> c f) <span class="fu">=</span> <span class="st">&quot;(I at &quot;</span> <span class="fu">++</span> show c <span class="fu">++</span> <span class="st">&quot; for &quot;</span> <span class="fu">++</span> show f <span class="fu">++</span> <span class="st">&quot;)&quot;</span></a>
<a class="sourceLine" id="cb20-19" data-line-number="19"></a>
<a class="sourceLine" id="cb20-20" data-line-number="20">showReal x <span class="fu">=</span> <span class="kw">if</span> isInt x <span class="kw">then</span> show (round x) <span class="kw">else</span> show x</a>
<a class="sourceLine" id="cb20-21" data-line-number="21">  <span class="kw">where</span> isInt x <span class="fu">=</span> x <span class="fu">==</span> fromInteger (round x)</a></code></pre></div>
<p>Not much to explain here. It’s just one way to print our syntax tree in a more readable way. What’s interesting is how we can now print our expressions in a much more human friendly way!</p>
<div class="sourceCode" id="cb21"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb21-1" data-line-number="1">ghci<span class="fu">&gt;</span> carPosition</a>
<a class="sourceLine" id="cb21-2" data-line-number="2">(<span class="dv">10</span> <span class="fu">+</span> ((<span class="dv">50</span> <span class="fu">+</span> (<span class="dv">20</span> <span class="fu">*</span> id)) <span class="fu">*</span> id))</a></code></pre></div>
<p>Still a bit noisy with all the parens, but much better!</p>
<p>Another class we need to instance for our <code>FunExpr</code> is <code>Arbitrary</code>. This class is associated with the testing library <em>QuickCheck</em>, and describes how to generate arbitrary values of a type for use when testing logical properties with <code>quickCheck</code>. For example, a property function could be formulated that states that the <code>:*</code> constructor of <code>FunExpr</code> is associative.</p>
<p>The implementation itself is not very interesting. We generate a function expression that tends to contain mostly elementary functions, arithmetic operations, and a generous dose of constants; with a light sprinkle of differences, derivatives, and integrals.</p>
<div class="sourceCode" id="cb22"><pre class="sourceCode literate haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb22-1" data-line-number="1"><span class="kw">instance</span> <span class="dt">Arbitrary</span> <span class="dt">FunExpr</span> <span class="kw">where</span></a>
<a class="sourceLine" id="cb22-2" data-line-number="2">  arbitrary <span class="fu">=</span></a></code></pre></div>
<p><code>frequency</code> “chooses one of the given generators, with a weighted random distribution”. By assigning probabilities of generating certain functions more often than others, we can restrain the growth of the generated expressions in complexity.</p>
<div class="sourceCode" id="cb23"><pre class="sourceCode literate haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb23-1" data-line-number="1">      frequency</a>
<a class="sourceLine" id="cb23-2" data-line-number="2">        [ (<span class="dv">10</span>, genElementary)</a>
<a class="sourceLine" id="cb23-3" data-line-number="3">        , (<span class="dv">10</span>, genBinaryOperation)</a>
<a class="sourceLine" id="cb23-4" data-line-number="4">        , (<span class="dv">10</span>, return <span class="dt">Id</span>)</a>
<a class="sourceLine" id="cb23-5" data-line-number="5">        , (<span class="dv">20</span>, fmap <span class="dt">Const</span> arbitrary)</a>
<a class="sourceLine" id="cb23-6" data-line-number="6">        , (<span class="dv">10</span>, genBinaryApp (<span class="fu">:.</span>))</a>
<a class="sourceLine" id="cb23-7" data-line-number="7">        , (<span class="dv">5</span> , genBinaryApp <span class="dt">Delta</span>)</a>
<a class="sourceLine" id="cb23-8" data-line-number="8">        , (<span class="dv">5</span> , fmap <span class="dt">D</span> arbitrary)</a>
<a class="sourceLine" id="cb23-9" data-line-number="9">        , (<span class="dv">5</span> , genBinaryApp <span class="dt">I</span>) ]</a>
<a class="sourceLine" id="cb23-10" data-line-number="10">    <span class="kw">where</span> genElementary <span class="fu">=</span> elements [<span class="dt">Exp</span>, <span class="dt">Log</span>, <span class="dt">Sin</span>, <span class="dt">Cos</span>, <span class="dt">Asin</span>, <span class="dt">Acos</span>]</a>
<a class="sourceLine" id="cb23-11" data-line-number="11">          genBinaryApp op <span class="fu">=</span> fmap (\(f, g) <span class="ot">-&gt;</span> f <span class="ot">`op`</span> g) arbitrary</a>
<a class="sourceLine" id="cb23-12" data-line-number="12">          genBinaryOperation <span class="fu">=</span>     elements [(<span class="fu">:+</span>), (<span class="fu">:-</span>), (<span class="fu">:*</span>), (<span class="fu">:/</span>), (<span class="fu">:^</span>)]</a>
<a class="sourceLine" id="cb23-13" data-line-number="13">                               <span class="fu">&gt;&gt;=</span> genBinaryApp</a></code></pre></div>
<h2 id="deep-dark-differences">Deep, dark, differences</h2>
<p><img src="delta.png" title="Feel the might if the illum-... the delta!" class="float-img-left" /></p>
<p>A <em>difference</em> is, in it’s essence, quite simply the result of applying the operation of subtraction to two real number terms.</p>
<p><span class="math display">\[minuend - subtrahend = difference\]</span></p>
<p>Nice, great job, we’re done here, let’s move on.</p>
<p>…</p>
<p>Just kidding, of course there’s more to it than that.</p>
<p>In calculus, the term <em>difference</em> carries more meaning than usual. More than just a subtraction of arbitrary values, differences lie at the heart of calculations regarding rate of change, both average and instantaneous.</p>
<p>Quotients of differences of functions of the same time describe the average rate of change over the time period. For example, an average velocity can be described as the difference quotient of difference in position divided by difference in time.</p>
<p><span class="math display">\[v_{avg} = \frac{p_2 - p_1}{t_2 - t_1}\]</span> where <span class="math inline">\(p_n\)</span> is the position at time <span class="math inline">\(t_n\)</span>.</p>
<p>In the context of calculus, we use a special syntax for differences: the delta operator! With this, the previous definition can be rewritten as</p>
<p><span class="math display">\[v_{avg} = \frac{p_2 - p_1}{t_2 - t_1} = \frac{\Delta p}{\Delta t}\]</span>.</p>
<p>This is the informal definition of the delta operator used in <em>University Physics</em>:</p>
<p><span class="math display">\[ \Delta x = x_2 - x_1 \]</span></p>
<p>Ok, so it’s a difference. But what does <span class="math inline">\(x_2\)</span> and <span class="math inline">\(x_1\)</span> mean, and what do they come from? <span class="math inline">\(x_2\)</span> and <span class="math inline">\(x_1\)</span> are not explicitly bound anywhere, but seems reasonable to assume that <span class="math inline">\(x_i \in x\)</span> or equivalently, that <span class="math inline">\(x\)</span> is a function with a subscript index as an argument, that returns a <span class="math inline">\(\mathbb{R}\)</span>.</p>
<p>Further, the indices <span class="math inline">\(1,2\)</span> should not be thought of as specific constants, but rather arbitrary real number variables identified by these integers. Lets call them <span class="math inline">\(a,b\)</span> instead, to make it clear that they are not constants.</p>
<p><span class="math display">\[\Delta x = x_b - x_a\]</span></p>
<p>Now <span class="math inline">\(a,b\)</span> are implicitly bound. We make the binding explicit.</p>
<p><span class="math display">\[ (\Delta x)(a, b) = x_b - x_a \]</span></p>
<p>We compare this to the more formal definition of <em>forward difference</em> on wikipedia:</p>
<p><span class="math display">\[\Delta_h[f](x) = f(x + h) - f(x)\]</span></p>
<p>The parameter bindings are a bit all over the place here. To more easily compare to our definition, let’s rename <span class="math inline">\(x\)</span> to <span class="math inline">\(a\)</span> and <span class="math inline">\(f\)</span> to <span class="math inline">\(x\)</span>, and change the parameter declaration syntax:</p>
<p><span class="math display">\[ (\Delta x)(h)(a) = x(a + h) - x(a) \]</span></p>
<p>This is almost identical to the definition we arrived at earlier, with the exception of expressing <span class="math inline">\(b\)</span> as <span class="math inline">\(a + h\)</span>. Why is this? Well, in calculus we mainly use differences to express two things, as mentioned previously. Average rate of change and instantaneous rate of change.</p>
<p>Average rate of change is best described as the difference quotient of the difference in y-axis value over an interval of x, divided by the difference in x-axis value over the same interval.</p>
<p><span class="math display">\[\frac{y(x_b) - y(x_a)}{x_b - x_a}\]</span>.</p>
<p>In this case, the <span class="math inline">\(x\)</span>’s can be at arbitrary points on the axis, as long as <span class="math inline">\(b &gt; a\)</span>. Therefore, the definition of difference as <span class="math inline">\((\Delta x)(a, b) = x_b - x_a\)</span> seems a good fit. Applied to average velocity, our difference quotient</p>
<p><span class="math display">\[v_{avg} = \frac{\Delta p}{\Delta t}\]</span></p>
<p>will expand to</p>
<p><span class="math display">\[v_{avg}(t_2, t_1) = \frac{(\Delta p)(t_2, t_1)}{(\Delta t)(t_2, t_1)}\]</span> for <span class="math inline">\(t_2 &gt; t_1\)</span>.</p>
<p>Instantaneous rate of change is more complicated. At its heart, it too is defined in terms of differences. However, we are no longer looking at the average change over an interval delimited by two points, but rather the instantaneous change in a single point.</p>
<p>Of course, you can’t have a difference with only one point. You need two points to look at how the function value changes between them. But what if we make the second point reeeeeeeeealy close to the first? That’s basically the same as the difference in a single point, for all intents and purposes. And so, for instantaneous rate of change, the definition of difference as <span class="math inline">\((\Delta x)(h)(a) = x(a + h) - x(a)\)</span> will make more sense, for very small <span class="math inline">\(h\)</span>’s. Applied to instantaneous velocity, our difference quotient</p>
<p><span class="math display">\[v_{inst} = \frac{\Delta p}{\Delta t}\]</span></p>
<p>for very small <span class="math inline">\(\Delta t\)</span>, will expand to</p>
<p><span class="math display">\[v_{inst}(h, x) = \frac{(\Delta p)(h, x)}{(\Delta t)(h, x)}\]</span></p>
<p>for very small <span class="math inline">\(h\)</span>.</p>
<p>As <span class="math inline">\(h\)</span> gets closer to <span class="math inline">\(0\)</span>, our approximation of instantaneous rate of change gets better.</p>
<p>And so, we have a method of computing average rate of change, and instantaneous rate of change (numerically approximatively). In Haskell, we can make shallow embeddings for differences in the context of rate of change as velocity.</p>
<p>Average velocity is simply</p>
<div class="sourceCode" id="cb24"><pre class="sourceCode literate haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb24-1" data-line-number="1">v_avg pos t2 t1 <span class="fu">=</span> (pos(t2) <span class="fu">-</span> pos(t1)) <span class="fu">/</span> (t2 <span class="fu">-</span> t1)</a></code></pre></div>
<p>which can be used as</p>
<div class="sourceCode" id="cb25"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb25-1" data-line-number="1">ghci<span class="fu">&gt;</span> v_avg (\x <span class="ot">-&gt;</span> <span class="dv">5</span><span class="fu">*</span>x) <span class="dv">10</span> <span class="dv">0</span></a>
<a class="sourceLine" id="cb25-2" data-line-number="2"><span class="fl">5.0</span></a></code></pre></div>
<p>And instantaneous velocity is</p>
<div class="sourceCode" id="cb26"><pre class="sourceCode literate haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb26-1" data-line-number="1">v_inst pos h t <span class="fu">=</span> (pos(t <span class="fu">+</span> h) <span class="fu">-</span> pos(t)) <span class="fu">/</span> ((t <span class="fu">+</span> h) <span class="fu">-</span> t)</a></code></pre></div>
<p>which can be used as</p>
<div class="sourceCode" id="cb27"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb27-1" data-line-number="1">ghci<span class="fu">&gt;</span> carSpeed t <span class="fu">=</span> v_inst (\x <span class="ot">-&gt;</span> x <span class="fu">+</span> sin(x)) <span class="fl">0.00001</span> t</a>
<a class="sourceLine" id="cb27-2" data-line-number="2">ghci<span class="fu">&gt;</span> carSpeedAtPointsInTime <span class="fu">=</span> map carSpeed [<span class="dv">0</span>, <span class="dv">1</span>, <span class="dv">2</span>, <span class="dv">3</span>]</a>
<a class="sourceLine" id="cb27-3" data-line-number="3">ghci<span class="fu">&gt;</span> carSpeedAtPointsInTime</a>
<a class="sourceLine" id="cb27-4" data-line-number="4">[<span class="fl">1.9999999999833333</span>,<span class="fl">1.5402980985023251</span>,<span class="fl">0.5838486169602084</span>,<span class="fl">1.0006797790330592e-2</span>]</a></code></pre></div>
<p>We’d also like to model one of the versions of the delta operator, finite difference, in our syntax tree. As the semantic value of our calculus language is the unary real function, the difference used for averages doesn’t really fit in well, as it’s a binary function (two arguments: <span class="math inline">\(t_2\)</span> and <span class="math inline">\(t_1\)</span>). Instead, we’ll use the version of delta used for instantants, as it only takes a single point in time as an argument (assuming <span class="math inline">\(h\)</span> is already given).</p>
<p>The constructor in our syntax tree is therefore</p>
<div class="sourceCode" id="cb28"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb28-1" data-line-number="1">    <span class="fu">|</span> <span class="dt">Delta</span> <span class="dt">RealNum</span> <span class="dt">FunExpr</span></a></code></pre></div>
<p>where the first argument is <span class="math inline">\(h\)</span>, and the second is the function.</p>
<h1 id="derivatives">Derivatives</h1>
<p>The <em>derivative</em> of a function is, according to wikipedia, “the slope of the tangent line to the graph of [a] function at [a] point” and can be described as the “instantaneous rate of change”, and <em>differentiation</em> is the method of finding a derivative for a function.</p>
<p>…</p>
<p>Wait, didn’t we just look at instantaneous rates of changes (blarh my tounge is getting tired) in the previous section on differences? Well yes, and the difference quotient for a function at a point with a very small step <span class="math inline">\(h\)</span> is indeed a good way to numerically approximate the derivative of a function. From what we found then, we can derive a general expression for instantaneous rate of change</p>
<p><span class="math display">\[\frac{(\Delta f)(h, x)}{(\Delta id)(h, x)} = \frac{f(x + h) - f(x)}{h}\]</span></p>
<p>for very small <span class="math inline">\(h\)</span>.</p>
<p>But what if we don’t want just a numerical approximation, but THE derivative of a function at any arbitrary point? What if we make <span class="math inline">\(h\)</span> not just very small, but <em>infinitley</em> small?</p>
<p>Introducing <em>infinitesimals</em>! From the wikipedia entry on <em>Leibniz’s notation</em></p>
<blockquote>
<p>In calculus, Leibniz’s notation, named in honor of the 17th-century German philosopher and mathematician Gottfried Wilhelm Leibniz, uses the symbols <span class="math inline">\(dx\)</span> and <span class="math inline">\(dy\)</span> to represent infinitely small (or infinitesimal) increments of x and y, respectively, just as <span class="math inline">\(\Delta x\)</span> and <span class="math inline">\(\Delta y\)</span> represent finite increments of x and y, respectively.</p>
</blockquote>
<p>So there’s a special syntax for differences where the step <span class="math inline">\(h\)</span> is infinitely small, and it’s called Leibniz’s notation. We interpret the above quote in mathematical terms:</p>
<p><span class="math display">\[dx = lim_{\Delta x \to 0} \Delta x\]</span></p>
<p>such that</p>
<p><span class="math display">\[\forall y(x). D(y) = \frac{dy}{dx} = \frac{lim_{\Delta y \to 0} \Delta y}
                                            {lim_{\Delta x \to 0} \Delta x}\]</span></p>
<p>where <span class="math inline">\(D\)</span> is the function of differentiation.</p>
<p>This definition of derivatives is very appealing, as it suggests a very simple and intuitive transition from finite differences to infinitesimal differentials. Also, it suggests the possibility of manipulating the infinitesimals of the derivative algebraically, which might be very useful. However, this concept is generally considered too imprecise to be used as the foundation of calculus.</p>
<p>A later section on the same wikipedia entry elaborates a bit:</p>
<blockquote>
<p>Leibniz’s concept of infinitesimals, long considered to be too imprecise to be used as a foundation of calculus, was eventually replaced by rigorous concepts developed by Weierstrass and others. Consequently, Leibniz’s quotient notation was re-interpreted to stand for the limit of the modern definition. However, in many instances, the symbol did seem to act as an actual quotient would and its usefulness kept it popular even in the face of several competing notations.</p>
</blockquote>
<p>What is then the “right” way to do derivatives? As luck would have it, not much differently than Leibniz’s suggested! The intuitive idea can be turned into a precise definition by defining the derivative to be the limit of difference quotients of real numbers. Again, from wikipedia - Leibniz’s notation:</p>
<blockquote>
<p>In its modern interpretation, the expression dy/dx should not be read as the division of two quantities dx and dy (as Leibniz had envisioned it); rather, the whole expression should be seen as a single symbol that is shorthand for</p>
<p><span class="math display">\[D(x) = lim_{\Delta x \to 0} \frac{\Delta y}{\Delta x}\]</span></p>
</blockquote>
<p>which, when <span class="math inline">\(y\)</span> is a function of <span class="math inline">\(x\)</span>, and <span class="math inline">\(x\)</span> is the <span class="math inline">\(id\)</span> function for real numbers (which it is in the case of time), is:</p>
<span class="math display">\[\begin{align*}
D(y) &amp;= lim_{\Delta x \to 0} \frac{\Delta y}{\Delta x} \\
     &amp;= a \mapsto lim_{\Delta x \to 0} \frac{(\Delta y)(\Delta x, a)}{\Delta x} \\
     &amp;= a \mapsto lim_{h \to 0} \frac{y(a + (\Delta x)(h, a)) - y(a)}{(\Delta x)(h, a)} \\
     &amp;= a \mapsto lim_{h \to 0} \frac{y(a + ((a + h) - a)) - y(a)}{(a + h) - a} \\
     &amp;= a \mapsto lim_{h \to 0} \frac{y(a + h) - y(a)}{h}
\end{align*}\]</span>
<p>There, the definition of derivatives! Not to complicated, was it?</p>
<p>The differentiation function is represented in our syntax tree as</p>
<div class="sourceCode" id="cb29"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb29-1" data-line-number="1">    <span class="fu">|</span> <span class="dt">D</span> <span class="dt">FunExpr</span></a></code></pre></div>
<p>Very simple!</p>
<p>And so, now what? What was the point of deriving that fancy definition for derivatives? Well, now we can derive things symbolically, which implies provable 100% perfect accuracy, no numeric approximations!</p>
<p>We define a function to symbolically derive a function expression. <code>derive</code> takes a function expression, and returns the derived function expression.</p>
<div class="sourceCode" id="cb30"><pre class="sourceCode literate haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb30-1" data-line-number="1"><span class="ot">derive ::</span> <span class="dt">FunExpr</span> <span class="ot">-&gt;</span> <span class="dt">FunExpr</span></a></code></pre></div>
<p>Using only the definition of derivatives, we can derive the definitions of <code>derive</code> for the various constructors in our syntax tree.</p>
<p>For example, how do we derive <code>f :+ g</code>? Let’s start by doing it mathematically.</p>
<span class="math display">\[\begin{align*}
D(f + g) &amp;= a \mapsto lim_{h \to 0} \frac{(f + g)[a + h] - (f + g)[a]}{h} \\
         &amp; \text{ \{ Addition of functions \} } \\
         &amp;= a \mapsto lim_{h \to 0} \frac{f(a + h) + g(a + h) - (f(a) + g(a))}{h} \\
         &amp;= a \mapsto lim_{h \to 0} \frac{f(a + h) + g(a + h) - f(a) - g(a)}{h} \\
         &amp;= a \mapsto lim_{h \to 0} (\frac{f(a + h) - f(a)}{h} + \frac{g(a + h) - g(a)}{h}) \\
         &amp;= a \mapsto ((lim_{h \to 0} \frac{f(a + h) - f(a)}{h}) + (lim_{h \to 0} \frac{g(a + h) - g(a)}{h})) \\
         &amp;= (a \mapsto lim_{h \to 0} \frac{f(a + h) - f(a)}{h}) + (a \mapsto lim_{h \to 0} \frac{g(a + h) - g(a)}{h}) \\
         &amp; \text{ \{ Definition of derivative \} } \\
         &amp;= D(f) + D(g)
\end{align*}\]</span>
<p>Oh, it’s just the sum of the derivatives of both functions! The Haskell implementation is then trivially</p>
<div class="sourceCode" id="cb31"><pre class="sourceCode literate haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb31-1" data-line-number="1">derive (f <span class="fu">:+</span> g) <span class="fu">=</span> derive f <span class="fu">:+</span> derive g</a></code></pre></div>
<p>Let’s do one more, say, <span class="math inline">\(sin\)</span>. We will make use of the trigonometric identity of sum-to-product</p>
<p><span class="math display">\[\sin \theta - \sin \varphi = 2 \sin\left(\frac{\theta - \varphi}{2}\right) \cos\left(\frac{\theta + \varphi}{2}\right)\]</span></p>
<p>And the limit</p>
<p><span class="math display">\[\lim_{x \to 0} \frac{sin x}{x} = 1\]</span></p>
<p>which can be proved using the unit circle and squeeze theorem, but we won’t do that here.</p>
<p>Then, the differentiation</p>
<span class="math display">\[\begin{align*}
D(sin) &amp;= a \mapsto lim_{h \to 0} \frac{sin(a + h) - sin(a)}{h} \\
       &amp; \text{ \{ trig. sum-to-product \} } \\
       &amp;= a \mapsto lim_{h \to 0} \frac{2 \sin\left(\frac{a + h - a}{2}\right) \cos\left(\frac{a + h + a}{2}\right)}{h} \\
       &amp;= a \mapsto lim_{h \to 0} \frac{2 \sin\left(\frac{h}{2}\right) \cos\left(\frac{2a + h}{2}\right)}{h} \\
       &amp;= a \mapsto lim_{h \to 0} \frac{2 \sin\left(\frac{h}{2}\right) \cos\left(\frac{2a + h}{2}\right)}{h} \\
       &amp;= a \mapsto lim_{h \to 0} \frac{\sin\left(\frac{h}{2}\right)}{\frac{h}{2}} \cos\left(\frac{2a + h}{2}\right)} \\
       &amp; \text{\{} h \text{ approaches } 0 \text{\}} \\
       &amp;= a \mapsto 1 \cos\left(\frac{2a + 0}{2}\right) \\
       &amp;= a \mapsto \cos(a) \\
       &amp;= \cos \\
\end{align*}\]</span>
<p>Again, trivial definition in Haskell</p>
<div class="sourceCode" id="cb32"><pre class="sourceCode literate haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb32-1" data-line-number="1">derive <span class="dt">Sin</span> <span class="fu">=</span> <span class="dt">Cos</span></a></code></pre></div>
<p>I’ll leave the proving of the rest of the implementations as an exercise to you.</p>
<div class="sourceCode" id="cb33"><pre class="sourceCode literate haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb33-1" data-line-number="1">derive <span class="dt">Exp</span> <span class="fu">=</span> <span class="dt">Exp</span></a>
<a class="sourceLine" id="cb33-2" data-line-number="2">derive <span class="dt">Log</span> <span class="fu">=</span> <span class="dt">Const</span> <span class="dv">1</span> <span class="fu">:/</span> <span class="dt">Id</span></a>
<a class="sourceLine" id="cb33-3" data-line-number="3">derive <span class="dt">Cos</span> <span class="fu">=</span> <span class="dt">Const</span> <span class="dv">0</span> <span class="fu">:-</span> <span class="dt">Sin</span></a>
<a class="sourceLine" id="cb33-4" data-line-number="4">derive <span class="dt">Asin</span> <span class="fu">=</span> <span class="dt">Const</span> <span class="dv">1</span> <span class="fu">:/</span> (<span class="dt">Const</span> <span class="dv">1</span> <span class="fu">:-</span> <span class="dt">Id</span><span class="fu">:^</span>(<span class="dt">Const</span> <span class="dv">2</span>))<span class="fu">:^</span>(<span class="dt">Const</span> <span class="fl">0.5</span>)</a>
<a class="sourceLine" id="cb33-5" data-line-number="5">derive <span class="dt">Acos</span> <span class="fu">=</span> <span class="dt">Const</span> <span class="dv">0</span> <span class="fu">:-</span> derive <span class="dt">Asin</span></a>
<a class="sourceLine" id="cb33-6" data-line-number="6">derive (f <span class="fu">:-</span> g) <span class="fu">=</span> derive f <span class="fu">:-</span> derive g</a>
<a class="sourceLine" id="cb33-7" data-line-number="7">derive (f <span class="fu">:*</span> g) <span class="fu">=</span> derive f <span class="fu">:*</span> g <span class="fu">:+</span> f <span class="fu">:*</span> derive g</a>
<a class="sourceLine" id="cb33-8" data-line-number="8">derive (f <span class="fu">:/</span> g) <span class="fu">=</span> (derive f <span class="fu">:*</span> g <span class="fu">:-</span> f <span class="fu">:*</span> derive g) <span class="fu">:/</span> (g<span class="fu">:^</span>(<span class="dt">Const</span> <span class="dv">2</span>))</a>
<a class="sourceLine" id="cb33-9" data-line-number="9">derive (f <span class="fu">:^</span> g) <span class="fu">=</span> f<span class="fu">:^</span>(g <span class="fu">:-</span> <span class="dt">Const</span> <span class="dv">1</span>) <span class="fu">:*</span> (g <span class="fu">:*</span> derive f <span class="fu">:+</span> f <span class="fu">:*</span> (<span class="dt">Log</span> <span class="fu">:.</span> f) <span class="fu">:*</span> derive g)</a>
<a class="sourceLine" id="cb33-10" data-line-number="10">derive <span class="dt">Id</span> <span class="fu">=</span> <span class="dt">Const</span> <span class="dv">1</span></a>
<a class="sourceLine" id="cb33-11" data-line-number="11">derive (<span class="dt">Const</span> _) <span class="fu">=</span> <span class="dt">Const</span> <span class="dv">0</span></a>
<a class="sourceLine" id="cb33-12" data-line-number="12">derive (f <span class="fu">:.</span> g) <span class="fu">=</span> derive g <span class="fu">:*</span> (derive f <span class="fu">:.</span> g)</a>
<a class="sourceLine" id="cb33-13" data-line-number="13">derive (<span class="dt">Delta</span> h f) <span class="fu">=</span> <span class="dt">Delta</span> h (derive f)</a>
<a class="sourceLine" id="cb33-14" data-line-number="14">derive (<span class="dt">D</span> f) <span class="fu">=</span> derive (derive f)</a></code></pre></div>
<p>Oh right, I almost forgot: Integrals. How are you supposed to know how to derive these bad boys when we haven’t even covered them yet! We’ll prove why this works later, but for now, just know that another name for integral is <em>Antiderivative</em>…</p>
<div class="sourceCode" id="cb34"><pre class="sourceCode literate haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb34-1" data-line-number="1">derive (<span class="dt">I</span> c f) <span class="fu">=</span> f</a></code></pre></div>
<h2 id="keep-it-simple">Keep it simple</h2>
<p>So we’ve got our differentiation function, great! Let’s try it out by finding the derivative for a simple function, like <span class="math inline">\(f(x) = sin(x) + x^2\)</span>, which should be <span class="math inline">\(f&#39;(x) = cos(x) + 2x\)</span>:</p>
<div class="sourceCode" id="cb35"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb35-1" data-line-number="1">ghci<span class="fu">&gt;</span> f <span class="fu">=</span> <span class="dt">Sin</span> <span class="fu">:+</span> <span class="dt">Id</span><span class="fu">:^</span>(<span class="dt">Const</span> <span class="dv">2</span>)</a>
<a class="sourceLine" id="cb35-2" data-line-number="2">ghci<span class="fu">&gt;</span> derive f</a>
<a class="sourceLine" id="cb35-3" data-line-number="3">(cos <span class="fu">+</span> ((id<span class="fu">^</span>(<span class="dv">2</span> <span class="fu">-</span> <span class="dv">1</span>)) <span class="fu">*</span> ((<span class="dv">2</span> <span class="fu">*</span> <span class="dv">1</span>) <span class="fu">+</span> ((id <span class="fu">*</span> (log <span class="fu">.</span> id)) <span class="fu">*</span> <span class="dv">0</span>))))</a></code></pre></div>
<p>Oh… that’s not very readable. If we simplify it manually we get that the result is indeed as expected</p>
<div class="sourceCode" id="cb36"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb36-1" data-line-number="1">(cos <span class="fu">+</span> ((id<span class="fu">^</span>(<span class="dv">2</span> <span class="fu">-</span> <span class="dv">1</span>)) <span class="fu">*</span> ((<span class="dv">2</span> <span class="fu">*</span> <span class="dv">1</span>) <span class="fu">+</span> ((id <span class="fu">*</span> (log <span class="fu">.</span> id)) <span class="fu">*</span> <span class="dv">0</span>))))</a>
<a class="sourceLine" id="cb36-2" data-line-number="2">cos <span class="fu">+</span> (id<span class="fu">^</span><span class="dv">1</span> <span class="fu">*</span> (<span class="dv">2</span> <span class="fu">+</span> (id <span class="fu">*</span> (log <span class="fu">.</span> id) <span class="fu">*</span> <span class="dv">0</span>)))</a>
<a class="sourceLine" id="cb36-3" data-line-number="3">cos <span class="fu">+</span> (id <span class="fu">*</span> (<span class="dv">2</span> <span class="fu">+</span> <span class="dv">0</span>))</a>
<a class="sourceLine" id="cb36-4" data-line-number="4">cos <span class="fu">+</span> <span class="dv">2</span><span class="fu">*</span>id</a></code></pre></div>
<p>But still, we shouldn’t have to do that manually! Let’s have Mr. Computer help us out, by writing a function to simplify expressions.</p>
<div class="sourceCode" id="cb37"><pre class="sourceCode literate haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb37-1" data-line-number="1"><span class="co">{-</span></a>
<a class="sourceLine" id="cb37-2" data-line-number="2"><span class="co">simplify :: FunExpr -&gt; FunExpr</span></a></code></pre></div>
<p>The elementary functions by themselves are already as simple as can be, so we don’t have to simplify those. When it comes to the arithmetic operations, we want to look at the identity and zero elements.</p>
<div class="sourceCode" id="cb38"><pre class="sourceCode literate haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb38-1" data-line-number="1">simplify (f <span class="fu">:+</span> g) <span class="fu">=</span> <span class="kw">case</span> (simplify f, simplify g) <span class="kw">of</span></a>
<a class="sourceLine" id="cb38-2" data-line-number="2">    (<span class="dt">Const</span> <span class="dv">0</span>, g&#39;) <span class="ot">-&gt;</span> g&#39;</a>
<a class="sourceLine" id="cb38-3" data-line-number="3">    (f&#39;, <span class="dt">Const</span> <span class="dv">0</span>) <span class="ot">-&gt;</span> f&#39;</a>
<a class="sourceLine" id="cb38-4" data-line-number="4">    (<span class="dt">Const</span> a, <span class="dt">Const</span> b) <span class="ot">-&gt;</span> <span class="dt">Const</span> (a <span class="fu">+</span> b)</a>
<a class="sourceLine" id="cb38-5" data-line-number="5">    (f&#39;, g&#39;) <span class="fu">|</span> f&#39; <span class="fu">==</span> g&#39; <span class="ot">-&gt;</span> simplify (<span class="dt">Const</span> <span class="dv">2</span> <span class="fu">:*</span> f&#39;)</a>
<a class="sourceLine" id="cb38-6" data-line-number="6">    (a <span class="fu">:*</span> f&#39;, g&#39;) <span class="fu">|</span> f&#39; <span class="fu">==</span> g&#39; <span class="ot">-&gt;</span> simplify (<span class="dt">Const</span> (a <span class="fu">+</span> <span class="dv">1</span>) <span class="fu">:*</span> f&#39;)</a>
<a class="sourceLine" id="cb38-7" data-line-number="7">    (f&#39;, <span class="dt">Const</span> a <span class="fu">:*</span> g&#39;) <span class="fu">|</span> f&#39; <span class="fu">==</span> g&#39; <span class="ot">-&gt;</span> simplify (<span class="dt">Const</span> (a <span class="fu">+</span> <span class="dv">1</span>) <span class="fu">:*</span> f&#39;)</a>
<a class="sourceLine" id="cb38-8" data-line-number="8">    (<span class="dt">Const</span> a <span class="fu">:*</span> f&#39;, <span class="dt">Const</span> b <span class="fu">:*</span> g&#39;) <span class="fu">|</span> f&#39; <span class="fu">==</span> g&#39; <span class="ot">-&gt;</span> simplify (<span class="dt">Const</span> (a <span class="fu">+</span> b) <span class="fu">:*</span> f&#39;)</a>
<a class="sourceLine" id="cb38-9" data-line-number="9">simplify (f <span class="fu">:-</span> g) <span class="fu">=</span></a>
<a class="sourceLine" id="cb38-10" data-line-number="10">simplify (f <span class="fu">:*</span> g) <span class="fu">=</span></a>
<a class="sourceLine" id="cb38-11" data-line-number="11">simplify (f <span class="fu">:/</span> g) <span class="fu">=</span></a>
<a class="sourceLine" id="cb38-12" data-line-number="12">simplify (f <span class="fu">:^</span> g) <span class="fu">=</span></a>
<a class="sourceLine" id="cb38-13" data-line-number="13">simplify <span class="dt">Id</span> <span class="fu">=</span></a>
<a class="sourceLine" id="cb38-14" data-line-number="14">simplify (<span class="dt">Const</span> x) <span class="fu">=</span></a>
<a class="sourceLine" id="cb38-15" data-line-number="15">simplify (f <span class="fu">:.</span> g) <span class="fu">=</span></a>
<a class="sourceLine" id="cb38-16" data-line-number="16">simplify (<span class="dt">Delta</span> h f) <span class="fu">=</span></a>
<a class="sourceLine" id="cb38-17" data-line-number="17">simplify (<span class="dt">D</span> f) <span class="fu">=</span></a>
<a class="sourceLine" id="cb38-18" data-line-number="18">simplify (<span class="dt">I</span> c f) <span class="fu">=</span></a>
<a class="sourceLine" id="cb38-19" data-line-number="19">simplify f <span class="fu">=</span> f</a></code></pre></div>
<div class="sourceCode" id="cb39"><pre class="sourceCode literate haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb39-1" data-line-number="1"><span class="ot">simplify ::</span> <span class="dt">Expr</span> <span class="ot">-&gt;</span> <span class="dt">Expr</span></a>
<a class="sourceLine" id="cb39-2" data-line-number="2">simplify (<span class="dt">Const</span> <span class="dv">0</span> <span class="fu">:*</span> b) <span class="fu">=</span> <span class="dv">0</span></a>
<a class="sourceLine" id="cb39-3" data-line-number="3">simplify (<span class="dt">Const</span> <span class="dv">1</span> <span class="fu">:*</span> b) <span class="fu">=</span> simplify b</a>
<a class="sourceLine" id="cb39-4" data-line-number="4">simplify (<span class="dt">Const</span> a <span class="fu">:*</span> <span class="dt">Const</span> b) <span class="fu">=</span> <span class="dt">Const</span> (a <span class="fu">*</span> b)</a>
<a class="sourceLine" id="cb39-5" data-line-number="5">simplify ((<span class="dt">Const</span> a <span class="fu">:*</span> b) <span class="fu">:+</span> c) <span class="fu">|</span> b&#39; <span class="fu">==</span> c&#39;  <span class="fu">=</span> <span class="dt">Const</span> (a <span class="fu">+</span> <span class="dv">1</span>) <span class="fu">:*</span> b&#39;</a>
<a class="sourceLine" id="cb39-6" data-line-number="6">                               <span class="fu">|</span> otherwise <span class="fu">=</span> (<span class="dt">Const</span> a <span class="fu">:*</span> b&#39;) <span class="fu">:+</span> c&#39;</a>
<a class="sourceLine" id="cb39-7" data-line-number="7">  <span class="kw">where</span> b&#39; <span class="fu">=</span> simplify b</a>
<a class="sourceLine" id="cb39-8" data-line-number="8">        c&#39; <span class="fu">=</span> simplify c</a>
<a class="sourceLine" id="cb39-9" data-line-number="9">simplify (c <span class="fu">:+</span> (<span class="dt">Const</span> a <span class="fu">:*</span> b)) <span class="fu">=</span> simplify ((<span class="dt">Const</span> a <span class="fu">:*</span> b) <span class="fu">:+</span> c)</a>
<a class="sourceLine" id="cb39-10" data-line-number="10">simplify (<span class="dt">Const</span> a <span class="fu">:*</span> b) <span class="fu">=</span> <span class="dt">Const</span> a <span class="fu">:*</span> simplify b</a>
<a class="sourceLine" id="cb39-11" data-line-number="11">simplify (a <span class="fu">:*</span> <span class="dt">Const</span> b) <span class="fu">=</span> simplify (<span class="dt">Const</span> b <span class="fu">:*</span> a)</a>
<a class="sourceLine" id="cb39-12" data-line-number="12">simplify (a <span class="fu">:*</span> b) <span class="fu">=</span> simplify a <span class="fu">:*</span> simplify b</a>
<a class="sourceLine" id="cb39-13" data-line-number="13">simplify (<span class="dt">Const</span> <span class="dv">0</span> <span class="fu">:+</span> b) <span class="fu">=</span> simplify b</a>
<a class="sourceLine" id="cb39-14" data-line-number="14">simplify (<span class="dt">Const</span> a <span class="fu">:+</span> <span class="dt">Const</span> b) <span class="fu">=</span> <span class="dt">Const</span> (a <span class="fu">+</span> b)</a>
<a class="sourceLine" id="cb39-15" data-line-number="15">simplify (<span class="dt">Const</span> a <span class="fu">:+</span> b) <span class="fu">=</span> <span class="dt">Const</span> a <span class="fu">:+</span> simplify b</a>
<a class="sourceLine" id="cb39-16" data-line-number="16">simplify (a <span class="fu">:+</span> <span class="dt">Const</span> b) <span class="fu">=</span> simplify (<span class="dt">Const</span> b <span class="fu">:+</span> a)</a>
<a class="sourceLine" id="cb39-17" data-line-number="17">simplify (a <span class="fu">:+</span> b) <span class="fu">|</span> a&#39; <span class="fu">==</span> b&#39;             <span class="fu">=</span> simplify (<span class="dv">2</span> <span class="fu">*</span> a&#39;)</a>
<a class="sourceLine" id="cb39-18" data-line-number="18">                  <span class="fu">|</span> (a <span class="fu">+</span> b) <span class="fu">==</span> (a&#39; <span class="fu">+</span> b&#39;) <span class="fu">=</span> a <span class="fu">+</span> b</a>
<a class="sourceLine" id="cb39-19" data-line-number="19">                  <span class="fu">|</span> otherwise            <span class="fu">=</span> simplify (a&#39; <span class="fu">+</span> b&#39;)</a>
<a class="sourceLine" id="cb39-20" data-line-number="20">  <span class="kw">where</span> a&#39; <span class="fu">=</span> simplify a</a>
<a class="sourceLine" id="cb39-21" data-line-number="21">        b&#39; <span class="fu">=</span> simplify b</a>
<a class="sourceLine" id="cb39-22" data-line-number="22">simplify (<span class="dt">Const</span> <span class="dv">0</span> <span class="fu">:-</span> b) <span class="fu">=</span> simplify (negate (simplify b))</a>
<a class="sourceLine" id="cb39-23" data-line-number="23">simplify (<span class="dt">Const</span> a <span class="fu">:-</span> <span class="dt">Const</span> b) <span class="fu">=</span> <span class="dt">Const</span> (a <span class="fu">-</span> b)</a>
<a class="sourceLine" id="cb39-24" data-line-number="24">simplify (<span class="dt">Const</span> a <span class="fu">:-</span> b) <span class="fu">=</span> <span class="dt">Const</span> a <span class="fu">:-</span> simplify b</a>
<a class="sourceLine" id="cb39-25" data-line-number="25">simplify (a <span class="fu">:-</span> <span class="dt">Const</span> b) <span class="fu">=</span> simplify (<span class="dt">Const</span> (<span class="dv">0</span><span class="fu">-</span>b) <span class="fu">:+</span> a)</a>
<a class="sourceLine" id="cb39-26" data-line-number="26">simplify (<span class="dt">Lambda</span> p b) <span class="fu">=</span> <span class="dt">Lambda</span> p (simplify b)</a>
<a class="sourceLine" id="cb39-27" data-line-number="27">simplify e <span class="fu">=</span> e</a></code></pre></div>
<h2 id="verificationprooftest">Verification/proof/test</h2>
<p>???</p>
<h2 id="examples">Examples</h2>
<div class="sourceCode" id="cb40"><pre class="sourceCode literate haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb40-1" data-line-number="1">idE <span class="fu">=</span> <span class="dt">Lambda</span> <span class="st">&quot;_x&quot;</span> <span class="st">&quot;_x&quot;</span></a></code></pre></div>
<div class="sourceCode" id="cb41"><pre class="sourceCode literate haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb41-1" data-line-number="1">dF <span class="fu">=</span> simplify <span class="fu">.</span> derive</a>
<a class="sourceLine" id="cb41-2" data-line-number="2">dE <span class="fu">=</span> simplify <span class="fu">.</span> flip deriveEx <span class="st">&quot;x&quot;</span></a></code></pre></div>
<div class="sourceCode" id="cb42"><pre class="sourceCode literate haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb42-1" data-line-number="1">test_simplify1 <span class="fu">=</span> (<span class="fu">==</span>) (simplify (<span class="st">&quot;x&quot;</span> <span class="fu">+</span> <span class="st">&quot;x&quot;</span>))</a>
<a class="sourceLine" id="cb42-2" data-line-number="2">                      (<span class="dv">2</span> <span class="fu">*</span> <span class="st">&quot;x&quot;</span>)</a>
<a class="sourceLine" id="cb42-3" data-line-number="3">test_simplify2 <span class="fu">=</span> (<span class="fu">==</span>) (simplify (((<span class="dv">1</span> <span class="fu">+</span> <span class="dv">1</span>) <span class="fu">*</span> <span class="st">&quot;x&quot;</span>) <span class="fu">+</span> (<span class="st">&quot;x&quot;</span> <span class="fu">*</span> <span class="dv">1</span>)))</a>
<a class="sourceLine" id="cb42-4" data-line-number="4">                      (<span class="dv">3</span> <span class="fu">*</span> <span class="st">&quot;x&quot;</span>)</a>
<a class="sourceLine" id="cb42-5" data-line-number="5">test_derive1   <span class="fu">=</span> (<span class="fu">==</span>) (dF (<span class="dt">Func</span> <span class="st">&quot;sin&quot;</span> <span class="fu">+</span> idE))</a>
<a class="sourceLine" id="cb42-6" data-line-number="6">                      (<span class="dt">Func</span> <span class="st">&quot;cos&quot;</span> <span class="fu">+</span> const&#39; <span class="dv">1</span>)</a>
<a class="sourceLine" id="cb42-7" data-line-number="7">test_derive2   <span class="fu">=</span> (<span class="fu">==</span>) (dE (sin (sin (<span class="dt">Var</span> <span class="st">&quot;x&quot;</span>))))</a>
<a class="sourceLine" id="cb42-8" data-line-number="8">                      (cos <span class="st">&quot;x&quot;</span> <span class="fu">*</span> cos (sin (<span class="dt">Var</span> <span class="st">&quot;x&quot;</span>)))</a></code></pre></div>
<p>Let’s plot graphs!</p>
<div class="sourceCode" id="cb43"><pre class="sourceCode literate haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb43-1" data-line-number="1">test_plot1 <span class="fu">=</span> <span class="kw">let</span> fe <span class="fu">=</span> <span class="dt">Lambda</span> <span class="st">&quot;x&quot;</span> (<span class="st">&quot;x&quot;</span> <span class="fu">*</span> <span class="st">&quot;x&quot;</span>)</a>
<a class="sourceLine" id="cb43-2" data-line-number="2">                 fe&#39; <span class="fu">=</span> dF fe</a>
<a class="sourceLine" id="cb43-3" data-line-number="3">                 f <span class="fu">=</span> evalF [] fe</a>
<a class="sourceLine" id="cb43-4" data-line-number="4">                 f&#39; <span class="fu">=</span> evalF [] fe&#39;</a>
<a class="sourceLine" id="cb43-5" data-line-number="5">             <span class="kw">in</span> plot [<span class="dt">Fun</span> f</a>
<a class="sourceLine" id="cb43-6" data-line-number="6">                          (show fe),</a>
<a class="sourceLine" id="cb43-7" data-line-number="7">                      <span class="dt">Fun</span> f&#39;</a>
<a class="sourceLine" id="cb43-8" data-line-number="8">                          (<span class="st">&quot;(D &quot;</span> <span class="fu">++</span> show fe <span class="fu">++</span> <span class="st">&quot;) = &quot;</span> <span class="fu">++</span> show fe&#39;)]</a></code></pre></div>
<h1 id="integrals---an-integral-part-of-calculus">Integrals - An integral part of calculus</h1>
<p><img src="integral.png" title="A snaky integral" class="float-img-right" /></p>
<p>Integrals are used in the reversed way as derivatives.</p>
<p><span class="math display">\[ x_{traveled} = \int_{t_0}^{t_1} v(t) dt \]</span></p>
<p>TODO: Describe relationship between between “Definite integrals”, “Indefinite integrals”, and “Antiderivatives”.</p>
<p>The following quotes are cut from <a href="https://en.wikipedia.org/wiki/Fundamental_theorem_of_calculus">Wikipedia</a>.</p>
<blockquote>
<p>The fundamental theorem of calculus is a theorem that links the concept of differentiating a function with the concept of integrating a function.</p>
<p>The first part of the theorem, sometimes called the first fundamental theorem of calculus, states that one of the antiderivatives (also called indefinite integral), say F, of some function f may be obtained as the integral of f with a variable bound of integration. This implies the existence of antiderivatives for continuous functions.[1]</p>
<p>Conversely, the second part of the theorem, sometimes called the second fundamental theorem of calculus, states that the integral of a function f over some interval can be computed by using any one, say F, of its infinitely many antiderivatives. This part of the theorem has key practical applications, because explicitly finding the antiderivative of a function by symbolic integration allows for avoiding numerical integration to compute integrals.</p>
</blockquote>
<blockquote>
<p>Newton and Leibniz</p>
<p>The major advance in integration came in the 17th century with the independent discovery of the fundamental theorem of calculus by Newton and Leibniz. The theorem demonstrates a connection between integration and differentiation. This connection, combined with the comparative ease of differentiation, can be exploited to calculate integrals. In particular, the fundamental theorem of calculus allows one to solve a much broader class of problems. Equal in importance is the comprehensive mathematical framework that both Newton and Leibniz developed. Given the name infinitesimal calculus, it allowed for precise analysis of functions within continuous domains. This framework eventually became modern calculus, whose notation for integrals is drawn directly from the work of Leibniz. Formalization While Newton and Leibniz provided a systematic approach to integration, their work lacked a degree of rigour. Bishop Berkeley memorably attacked the vanishing increments used by Newton, calling them “ghosts of departed quantities”. Calculus acquired a firmer footing with the development of limits. Integration was first rigorously formalized, using limits, by Riemann. Although all bounded piecewise continuous functions are Riemann-integrable on a bounded interval, subsequently more general functions were considered—particularly in the context of Fourier analysis—to which Riemann’s definition does not apply, and Lebesgue formulated a different definition of integral, founded in measure theory (a subfield of real analysis). Other definitions of integral, extending Riemann’s and Lebesgue’s approaches, were proposed. These approaches based on the real number system are the ones most common today, but alternative approaches exist, such as a definition of integral as the standard part of an infinite Riemann sum, based on the hyperreal number system.</p>
</blockquote>
<p>Newton and Leibniz independently discovered the fundemental theorem of calculus. They based their definitions on infinitesimals which, as described above was considered too imprecise. Later, Riemann rigorously formalized integration using limits.</p>
<blockquote>
<p>There are many ways of formally defining an integral, not all of which are equivalent. The differences exist mostly to deal with differing special cases which may not be integrable under other definitions, but also occasionally for pedagogical reasons. The most commonly used definitions of integral are Riemann integrals and Lebesgue integrals.</p>
</blockquote>
<p>We only look at Riemann integrals for now, since they will likely be more familiar to most students (They are to me!).</p>
<blockquote>
<p>In the branch of mathematics known as real analysis, the Riemann integral, created by Bernhard Riemann, was the first rigorous definition of the integral of a function on an interval. It was presented to the faculty at the University of Göttingen in 1854, but not published in a journal until 1868.[1] For many functions and practical applications, the Riemann integral can be evaluated by the fundamental theorem of calculus or approximated by numerical integration.</p>
<p>The Riemann integral is unsuitable for many theoretical purposes. Some of the technical deficiencies in Riemann integration can be remedied with the Riemann–Stieltjes in &gt; tegral, and most disappear with the Lebesgue integral.</p>
</blockquote>
<p>See: <a href="https://mathoverflow.net/questions/52708/why-should-one-still-teach-riemann-integration">Why should one still teach Riemann integration? (Mathoverflow)</a></p>
<p>So there are some problems, but Riemann integrals will do for now.(?)</p>
<p>% Because we won’t do rigorous proofs requiring Lebesgue integrals in this course?</p>
<p>We will also only study definite integrals here, as indefinite integrals are not required to be used in this course anyway.</p>
<p>Geometrically (in 2D), the integral of a function over an interval is equivalent to the area under the graph of that function over the same interval.</p>
<blockquote>
<p>The definite integral is defined informally as the signed area of the region in the xy-plane that is bounded by the graph of f, the x-axis and the vertical lines <span class="math inline">\(x = a\)</span> and <span class="math inline">\(x = b\)</span>. The area above the x-axis adds to the total and that below the x-axis subtracts from the total.</p>
<p>– <cite><a href="https://en.wikipedia.org/wiki/Integral">Wikipedia - Integral</a></cite></p>
</blockquote>
<p>This is the syntax for definite integrals</p>
<p><span class="math display">\[ \int_a^b f(x) dx \]</span></p>
<p>This would be read as “The signed area under the graph of <span class="math inline">\(f(x)\)</span> from <span class="math inline">\(x=a\)</span> to <span class="math inline">\(x=b\)</span>”.</p>
<p>Clearly, the integral symbol binds <span class="math inline">\(a\)</span> and <span class="math inline">\(b\)</span> which are then the limits of the integral, and constitute the interval over which to integrate/take the area, and <span class="math inline">\(f\)</span> is the function which we integrate/take the area under. The less obvious part of the syntax is the <span class="math inline">\((x)\)</span> part in <span class="math inline">\(f(x)\)</span> and the <span class="math inline">\(dx\)</span>. Is <span class="math inline">\(x\)</span> an argument to be passed to the integral that is bound here? No. What this syntax actually implies is that, in english, “For every infinitesimal interval of <span class="math inline">\(x\)</span>, starting at <span class="math inline">\(a\)</span> and ending at <span class="math inline">\(b\)</span>, take the value of <span class="math inline">\(f\)</span> at that x (equiv. to taking the value at any point in the infinitesimal interval), and calculate the area of the rectangle with width <span class="math inline">\(dx\)</span> and height <span class="math inline">\(f(x)\)</span>, then sum all of these parts together.”</p>
<p>If we assume that <span class="math inline">\(f\)</span> is a unary function, which is the only kind of function we will be dealing with here, the syntax is redundant. <span class="math inline">\(dx\)</span> is completely internal to the behaviour of the function, and is not an argument bound by it, we could easily omitt it from the syntax. Further, if we see the integral as a function that integrates a function over an interval, <span class="math inline">\(\int_a^b f(x)\)</span> doesn’t really make any sense, and should just be <span class="math inline">\(\int_a^b f\)</span>.</p>
<p>This syntax is much simpler and leaves less room for confusion.</p>
<p><code>integrate f a b =</code> <span class="math inline">\(\int_a^b f\)</span></p>
<p>Now for the definition.</p>
<p>We look again at the informal definition above. <span class="math inline">\(\int_a^b f\)</span> is the sum of all rectangles with height <span class="math inline">\(f(x)\)</span> and width <span class="math inline">\(dx\)</span> for all infinitesimal intervals <span class="math inline">\(dx\)</span> between <span class="math inline">\(a\)</span> and <span class="math inline">\(b\)</span>.</p>
<p>So we’re dealing with an infinite sum of infinitesimal parts: a limit must be involved. <span class="math inline">\(a\)</span> and <span class="math inline">\(b\)</span> must be the lower and upper limits of the sum. Our iteration variable should increase with infinitesimal <span class="math inline">\(dx\)</span> each step. Each step we add the area of the rectangle with height <span class="math inline">\(f(x&#39;)\)</span>, where <span class="math inline">\(x&#39;\)</span> is any point in <span class="math inline">\([x\)</span>, <span class="math inline">\(x + dx]\)</span>. As <span class="math inline">\(x + dx\)</span> approaches <span class="math inline">\(x\)</span> when <span class="math inline">\(dx\)</span> approaches zero, <span class="math inline">\(x&#39; = lim_{dx \to 0} x + dx = x\)</span>.</p>
<p><span class="math display">\[ \int_a^b f = lim_{dx \to 0} \sum_{x = a, a + dx, a + 2dx, ...}^b A(x, dx) \text{ where } A(x, dx) = f(x) * dx \]</span></p>
<p>Based on this definition, we could implement a function in haskell to compute the numerical approximation of the integral by letting <span class="math inline">\(dx\)</span> be a very small, but finite, number instead of being infinitesimal. The smaller our <span class="math inline">\(dx\)</span>, the better the approximation</p>
<p>Here’s a pic that shows that smaller <span class="math inline">\(dx\)</span> results in better approximations:</p>
<figure>
<img src="https://upload.wikimedia.org/wikipedia/commons/2/2a/Riemann_sum_convergence.png" alt="Riemann sum convergence, (C) KSmrq" /><figcaption>Riemann sum convergence, (C) KSmrq</figcaption>
</figure>
<div class="sourceCode" id="cb44"><pre class="sourceCode literate haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb44-1" data-line-number="1">integrateApprox f a b dx <span class="fu">=</span> sum (fmap area xs)</a>
<a class="sourceLine" id="cb44-2" data-line-number="2">  <span class="kw">where</span> xs     <span class="fu">=</span> takeWhile (<span class="fu">&lt;</span>b) [a <span class="fu">+</span> <span class="dv">0</span><span class="fu">*</span>dx, a <span class="fu">+</span> <span class="dv">1</span><span class="fu">*</span>dx <span class="fu">..</span>]</a>
<a class="sourceLine" id="cb44-3" data-line-number="3">        area x <span class="fu">=</span> f x <span class="fu">*</span> dx</a></code></pre></div>
<p>For example, let’s calculate the area of the right-angled triangle under <span class="math inline">\(y = x\)</span> between <span class="math inline">\(x=0\)</span> and <span class="math inline">\(x=10\)</span>. As the area of a right-angled triangle is calculated as <span class="math inline">\(A = \frac{b * h}{2}\)</span>, we expect the result of  to approach <span class="math inline">\(A = \frac{b * h}{2} = \frac{10 * 10}{2} = 50\)</span> as <span class="math inline">\(dx\)</span> gets smaller</p>
<div class="sourceCode" id="cb45"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb45-1" data-line-number="1">λ integrateApprox (\textbackslash x <span class="ot">-&gt;</span> x) <span class="dv">0</span> <span class="dv">10</span> <span class="dv">5</span></a>
<a class="sourceLine" id="cb45-2" data-line-number="2"><span class="dv">25</span></a>
<a class="sourceLine" id="cb45-3" data-line-number="3">λ integrateApprox (\textbackslash x <span class="ot">-&gt;</span> x) <span class="dv">0</span> <span class="dv">10</span> <span class="dv">1</span></a>
<a class="sourceLine" id="cb45-4" data-line-number="4"><span class="dv">45</span></a>
<a class="sourceLine" id="cb45-5" data-line-number="5">λ integrateApprox (\textbackslash x <span class="ot">-&gt;</span> x) <span class="dv">0</span> <span class="dv">10</span> <span class="fl">0.5</span></a>
<a class="sourceLine" id="cb45-6" data-line-number="6"><span class="fl">47.5</span></a>
<a class="sourceLine" id="cb45-7" data-line-number="7">λ integrateApprox (\textbackslash x <span class="ot">-&gt;</span> x) <span class="dv">0</span> <span class="dv">10</span> <span class="fl">0.1</span></a>
<a class="sourceLine" id="cb45-8" data-line-number="8"><span class="fl">49.50000000000013</span></a>
<a class="sourceLine" id="cb45-9" data-line-number="9">λ integrateApprox (\textbackslash x <span class="ot">-&gt;</span> x) <span class="dv">0</span> <span class="dv">10</span> <span class="fl">0.01</span></a>
<a class="sourceLine" id="cb45-10" data-line-number="10"><span class="fl">50.04999999999996</span></a></code></pre></div>
<p>Great, it works for numeric approximations! This can be useful at times, but not so much in our case. We want closed expressions to use when solving physics problems, regardless of whether there are computations or not!</p>
<p>Luckily, the Fundamental Theorem of Calculus tells us that there IS a way to express integrals in closed form!</p>
<p>From the article on <a href="https://en.wikipedia.org/wiki/Fundamental_theorem_of_calculus">Wikipedia</a>:</p>
<blockquote>
<p>First part</p>
<p>This part is sometimes referred to as the first fundamental theorem of calculus.</p>
<p>Let <span class="math inline">\(f\)</span> be a continuous real-valued function defined on a closed interval <span class="math inline">\([a, b]\)</span>. Let <span class="math inline">\(F\)</span> be the function defined, for all <span class="math inline">\(x \in [a, b]\)</span>, by</p>
<p><span class="math display">\[ F(x) = \int_a^x f(t) dt \]</span></p>
<p>Then, <span class="math inline">\(F\)</span> is uniformly continuous on <span class="math inline">\([a,b]\)</span>, differentiable on the open interval <span class="math inline">\((a, b)\)</span> and</p>
<p><span class="math display">\[ F&#39;(x) = f(x) \]</span></p>
<p>for all <span class="math inline">\(x \in (a,b)\)</span>.</p>
<p>Alternatively, if <span class="math inline">\(f\)</span> is merely Riemann integrable, then <span class="math inline">\(F\)</span> is continuous on <span class="math inline">\([a,b]\)</span> (but not necessarily differentiable).</p>
<p>Corollary</p>
<p>The fundamental theorem is often employed to compute the definite integral of a function <span class="math inline">\(f\)</span> for which an antiderivative <span class="math inline">\(F\)</span> is known. Specifically, if <span class="math inline">\(f\)</span> is a real-valued continuous function on <span class="math inline">\([a,b]\)</span> and <span class="math inline">\(F\)</span> is an antiderivative of <span class="math inline">\(f\)</span> in <span class="math inline">\([a,b]\)</span> then</p>
<p><span class="math display">\[ \int_a^b f(t) dt = F(b) - F(a) \]</span></p>
<p>The corollary assumes continuity on the whole interval. This result is strengthened slightly in the following part of the theorem.</p>
<p>Second part</p>
<p>This part is sometimes referred to as the second fundamental theorem of calculus or the Newton–Leibniz axiom.</p>
<p>Let <span class="math inline">\(f\)</span> and <span class="math inline">\(f\)</span> be real-valued functions defined on a closed interval <span class="math inline">\([a,b]\)</span> such that <span class="math inline">\(f\)</span> is continuous on all <span class="math inline">\([a,b]\)</span> and the derivative of <span class="math inline">\(F\)</span> is <span class="math inline">\(f\)</span> for almost all points in <span class="math inline">\([a,b]\)</span>. That is, <span class="math inline">\(f\)</span> and <span class="math inline">\(F\)</span> are functions such that for all <span class="math inline">\(x \in (a,b)\)</span> except for perhaps a set of measure zero in the interval:</p>
<p><span class="math display">\[ F&#39;(x)=f(x) \]</span></p>
<p>If <span class="math inline">\(f\)</span> is Riemann integrable on <span class="math inline">\([a,b]\)</span> then</p>
<p><span class="math display">\[ \int_a^b f(x) dx = F(b) - F(a) \]</span></p>
<p>The second part is somewhat stronger than the corollary because it does not assume that <span class="math inline">\(f\)</span> is continuous.</p>
<p>When an antiderivative <span class="math inline">\(f\)</span> exists, then there are infinitely many antiderivatives for <span class="math inline">\(f\)</span>, obtained by adding an arbitrary constant to <span class="math inline">\(f\)</span>. Also, by the first part of the theorem, antiderivatives of <span class="math inline">\(f\)</span> always exist when <span class="math inline">\(f\)</span> is continuous.</p>
</blockquote>
<p>And here’s the proof. We won’t delve into this, but it’s quite simple.</p>
<blockquote>
<p>Bevis</p>
<p>Satsen kan bevisas enligt följande:</p>
<span class="math display">\[\begin{align*}
F&#39;(x) &amp;= \lim_{h \to 0} \frac{F(x + h) - F(x)}{h} \\
      &amp;= \lim_{h \to 0} \frac{1}{h} \left( \int_a^{x + h} f(t) dt - \int_a^x f(t) dt \right) \\
      &amp;= \lim_{h \to 0} \frac{1}{h} \int_x^{x + h} f(t) dt \\
      &amp;= \lim_{h \to 0} f(c) \\
      &amp;= \lim_{c \to x} f(c) \\
      &amp;= f(x)
\end{align*}\]</span>
<p>I första steget utnyttjas derivatans definition och i det andra definitionen av <span class="math inline">\(f\)</span>. I det tredje steget används räknelagar för integraler. I fjärde steget används medelvärdessatsen för integraler. I femte steget utnyttjas det faktum att <span class="math inline">\(c\)</span> ligger mellan <span class="math inline">\(x\)</span> och <span class="math inline">\(x + h\)</span>, så då <span class="math inline">\(h \to 0\)</span> gäller att <span class="math inline">\(c \to x\)</span>. Sista steget ges av att <span class="math inline">\(f\)</span> är kontinuerlig.</p>
<p>– <cite><a href="https://sv.wikipedia.org/wiki/Analysens_fundamentalsats">Wikipedia - Analysens Fundamentalsats</a></cite></p>
</blockquote>
<p>Let’s write a function for symbolic integration of functions. <code>integrate</code> will be the indefinite integration function, as it’s more powerful. Definite integrals can be expressed directly in terms of indefinite integrals, but not quite vice versa.</p>
<div class="sourceCode" id="cb46"><pre class="sourceCode literate haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb46-1" data-line-number="1"><span class="ot">integrate ::</span> <span class="dt">Expr</span> <span class="ot">-&gt;</span> <span class="dt">RealNum</span> <span class="ot">-&gt;</span> <span class="dt">Expr</span></a>
<a class="sourceLine" id="cb46-2" data-line-number="2">integrate (f <span class="fu">:+</span> g) c <span class="fu">=</span> (integrate f <span class="dv">0</span> <span class="fu">+</span> integrate g <span class="dv">0</span>) <span class="fu">+</span> const&#39; c</a>
<a class="sourceLine" id="cb46-3" data-line-number="3">integrate (f <span class="fu">:-</span> g) c <span class="fu">=</span> (integrate f <span class="dv">0</span> <span class="fu">-</span> integrate g <span class="dv">0</span>) <span class="fu">+</span> const&#39; c</a></code></pre></div>
<p>There exists a great product rule in the case of differentiation, but not for integration. There just doesn’t exist a great way to integrate a product that always works! The integration rule that’s most analogous to the product rule for differentiation, is integration by parts:</p>
<p><span class="math display">\[ \int f(x) g(x) dx = f(x) G(x) - \int f&#39;(x) g(x) dx \]</span></p>
<p>Hmm, this doesn’t look quite as helpful as the differentiation product rule, does it? We want this rule to give us an expression of simpler and/or fewer integrals, and it may indeed do so. For example, the integration of the product <span class="math inline">\(x * e^x\)</span> is a great examples of a case where it works well:</p>
<p><span class="math display">\[ \int x e^x dx = x e^x - \int 1 e^x dx = x e^x - e^x = e^x (x - 1) \]</span></p>
<p>Now THAT is a simplification.</p>
<p>However, just by flipping the order of the expressions, we get a case where the integration by parts rule only makes things worse:</p>
<p><span class="math display">\[ \int e^x x dx = e^x x^2 - \int e^x x dx = e^x x^2 - (e^x x^2 - \int e^x x dx) = e^x x^2 - (e^x x^2 - (e^x x^2 - \int e^x x dx)) = ... \]</span></p>
<p>Oh no, it’s an infinite recursion!</p>
<p>There is also the problem that the integration by parts rule is simply undefined in the case of <span class="math inline">\(g(x)\)</span> not being integrable to <span class="math inline">\(G(x)\)</span>. And so, as there exists no great way to do it, we’ll settle for a mediocre one! We’ll define the integration of a product to use integration by parts, but before integrating we’ll simplify the expression in the hopes that it will become better suited for integration.</p>
<div class="sourceCode" id="cb47"><pre class="sourceCode literate haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb47-1" data-line-number="1">integrate (f <span class="fu">:*</span> g) c <span class="fu">=</span></a>
<a class="sourceLine" id="cb47-2" data-line-number="2">    <span class="kw">let</span> simplified <span class="fu">=</span> simplify (f <span class="fu">*</span> g)</a>
<a class="sourceLine" id="cb47-3" data-line-number="3">    <span class="kw">in</span> <span class="kw">if</span> simplified <span class="fu">==</span> (f <span class="fu">*</span> g)</a>
<a class="sourceLine" id="cb47-4" data-line-number="4">       <span class="kw">then</span> f <span class="fu">*</span> integrate g <span class="dv">0</span> <span class="fu">-</span> integrate (derive f <span class="fu">*</span> g) <span class="dv">0</span> <span class="fu">+</span> const&#39; c</a>
<a class="sourceLine" id="cb47-5" data-line-number="5">       <span class="kw">else</span> integrate simplified c</a></code></pre></div>
<p>We get a similar rule for quotients</p>
<div class="sourceCode" id="cb48"><pre class="sourceCode literate haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb48-1" data-line-number="1">integrate (f <span class="fu">:/</span> g) c <span class="fu">=</span></a>
<a class="sourceLine" id="cb48-2" data-line-number="2">    <span class="kw">let</span> simplified <span class="fu">=</span> simplify (f <span class="fu">/</span> g)</a>
<a class="sourceLine" id="cb48-3" data-line-number="3">    <span class="kw">in</span> <span class="kw">if</span> simplified <span class="fu">==</span> (f <span class="fu">/</span> g)</a>
<a class="sourceLine" id="cb48-4" data-line-number="4">       <span class="kw">then</span> <span class="kw">let</span> _F <span class="fu">=</span> integrate f <span class="dv">0</span></a>
<a class="sourceLine" id="cb48-5" data-line-number="5">            <span class="kw">in</span> _F <span class="fu">/</span> g <span class="fu">+</span> integrate (_F <span class="fu">*</span> (derive g <span class="fu">/</span> (g<span class="fu">^</span><span class="dv">2</span>))) <span class="dv">0</span> <span class="fu">+</span> const&#39; c</a>
<a class="sourceLine" id="cb48-6" data-line-number="6">       <span class="kw">else</span> integrate simplified c</a></code></pre></div>
<p>Integration of function composition is, simply said, somewhat complicated. The technique to use is called “integration by substituted”, and is something like a reverse of the chain-rule of differentiation. Luckily, most beginner-to-intermediate physics courses purposfully avoid the use of composed functions when integration is required, and as such, we simply won’t implement it!</p>
<p>As long as we ensure our input functions are not composed functions, <code>integrate</code> will still be well behaved.</p>
<div class="sourceCode" id="cb49"><pre class="sourceCode literate haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb49-1" data-line-number="1">integrate (f <span class="fu">:.</span> g) c <span class="fu">=</span> error <span class="st">&quot;Please don&#39;t try to integrate function compositions!&quot;</span></a></code></pre></div>
<p>To integrate a lambda function, we simply integrate the body-expression with regards to the parameter variable</p>
<div class="sourceCode" id="cb50"><pre class="sourceCode literate haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb50-1" data-line-number="1">integrate (<span class="dt">Lambda</span> p b) c <span class="fu">=</span> <span class="dt">Lambda</span> p (integrateEx b p c)</a></code></pre></div>
<p>And then there are these functions. We just look up the formulas of integration in Wolfram Alpha or something.</p>
<div class="sourceCode" id="cb51"><pre class="sourceCode literate haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb51-1" data-line-number="1">integrate (<span class="dt">Func</span> <span class="st">&quot;log&quot;</span>) c <span class="fu">=</span> <span class="dt">Lambda</span> <span class="st">&quot;x&quot;</span> (<span class="st">&quot;x&quot;</span> <span class="fu">*</span> log <span class="st">&quot;x&quot;</span> <span class="fu">-</span> <span class="st">&quot;x&quot;</span> <span class="fu">+</span> const&#39; c)</a>
<a class="sourceLine" id="cb51-2" data-line-number="2">integrate (<span class="dt">Func</span> <span class="st">&quot;exp&quot;</span>) c <span class="fu">=</span> <span class="dt">Func</span> <span class="st">&quot;exp&quot;</span> <span class="fu">+</span> const&#39; c</a>
<a class="sourceLine" id="cb51-3" data-line-number="3">integrate (<span class="dt">Func</span> <span class="st">&quot;sin&quot;</span>) c <span class="fu">=</span> <span class="dt">Func</span> <span class="st">&quot;negate&quot;</span> <span class="fu">:.</span> <span class="dt">Func</span> <span class="st">&quot;cos&quot;</span> <span class="fu">+</span> const&#39; c</a>
<a class="sourceLine" id="cb51-4" data-line-number="4">integrate (<span class="dt">Func</span> <span class="st">&quot;cos&quot;</span>) c <span class="fu">=</span> <span class="dt">Func</span> <span class="st">&quot;sin&quot;</span> <span class="fu">+</span> const&#39; c</a>
<a class="sourceLine" id="cb51-5" data-line-number="5">integrate (<span class="dt">Func</span> <span class="st">&quot;asin&quot;</span>) c <span class="fu">=</span> <span class="dt">Lambda</span> <span class="st">&quot;x&quot;</span> (sqrt (<span class="dv">1</span> <span class="fu">-</span> <span class="st">&quot;x&quot;</span><span class="fu">^</span><span class="dv">2</span>) <span class="fu">+</span> <span class="st">&quot;x&quot;</span> <span class="fu">*</span> asin <span class="st">&quot;x&quot;</span> <span class="fu">+</span> const&#39; c)</a>
<a class="sourceLine" id="cb51-6" data-line-number="6">integrate (<span class="dt">Func</span> <span class="st">&quot;acos&quot;</span>) c <span class="fu">=</span> <span class="dt">Lambda</span> <span class="st">&quot;x&quot;</span> (<span class="st">&quot;x&quot;</span> <span class="fu">*</span> acos <span class="st">&quot;x&quot;</span> <span class="fu">-</span> sqrt (<span class="dv">1</span> <span class="fu">-</span> <span class="st">&quot;x&quot;</span><span class="fu">^</span><span class="dv">2</span>) <span class="fu">+</span> const&#39; c)</a>
<a class="sourceLine" id="cb51-7" data-line-number="7">integrate (<span class="dt">Func</span> <span class="st">&quot;negate&quot;</span>) c <span class="fu">=</span> <span class="dt">Func</span> <span class="st">&quot;negate&quot;</span> <span class="fu">+</span> const&#39; c</a>
<a class="sourceLine" id="cb51-8" data-line-number="8">integrate _ _ <span class="fu">=</span> undefined</a></code></pre></div>
<div class="sourceCode" id="cb52"><pre class="sourceCode literate haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb52-1" data-line-number="1"><span class="ot">integrateEx ::</span> <span class="dt">Expr</span> <span class="ot">-&gt;</span> <span class="dt">String</span> <span class="ot">-&gt;</span> <span class="dt">RealNum</span> <span class="ot">-&gt;</span> <span class="dt">Expr</span></a></code></pre></div>
<p>You probably already know the rule for integrating polynomials (which <span class="math inline">\(x\)</span> is a case of). It’s just the reverse of the simple differentiation rule!</p>
<p><span class="math display">\[ \int a_n x^n + a_{n-1} x^{n-1} + ... + a_1 x^1 + a_0 dx = \frac{a_n}{n+1} x^{n+1} + \frac{a_{n-1}}{n} x^{n} + ... + \frac{a_1}{2} x^2 + a_0 x^1 + C \]</span></p>
<p>implies that</p>
<p><span class="math display">\[ \int a dx = ax + C \]</span></p>
<p>and</p>
<p><span class="math display">\[ \int x dx = \frac{x^2}{2} + C \]</span></p>
<p>And so, we implement exactly that</p>
<div class="sourceCode" id="cb53"><pre class="sourceCode literate haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb53-1" data-line-number="1">integrateEx (<span class="dt">Const</span> a) v c <span class="fu">=</span> <span class="dt">Const</span> a <span class="fu">*</span> <span class="dt">Var</span> v <span class="fu">+</span> <span class="dt">Const</span> c</a>
<a class="sourceLine" id="cb53-2" data-line-number="2">integrateEx (<span class="dt">Var</span> u) v c <span class="fu">|</span> u <span class="fu">==</span> v    <span class="fu">=</span> (<span class="dt">Var</span> u)<span class="fu">^</span><span class="dv">2</span> <span class="fu">/</span> <span class="dv">2</span> <span class="fu">+</span> <span class="dt">Const</span> c</a>
<a class="sourceLine" id="cb53-3" data-line-number="3">                        <span class="fu">|</span> otherwise <span class="fu">=</span> <span class="dt">Var</span> u <span class="fu">*</span> <span class="dt">Var</span> v <span class="fu">+</span> <span class="dt">Const</span> c</a>
<a class="sourceLine" id="cb53-4" data-line-number="4">integrateEx (a <span class="fu">:+</span> b) v c <span class="fu">=</span> integrateEx a v <span class="dv">0</span> <span class="fu">+</span> integrateEx b v <span class="dv">0</span> <span class="fu">+</span> <span class="dt">Const</span> c</a>
<a class="sourceLine" id="cb53-5" data-line-number="5">integrateEx (a <span class="fu">:-</span> b) v c <span class="fu">=</span> integrateEx a v <span class="dv">0</span> <span class="fu">-</span> integrateEx b v <span class="dv">0</span> <span class="fu">+</span> <span class="dt">Const</span> c</a>
<a class="sourceLine" id="cb53-6" data-line-number="6">integrateEx (a <span class="fu">:*</span> b) v c <span class="fu">=</span></a>
<a class="sourceLine" id="cb53-7" data-line-number="7">    <span class="kw">let</span> simplified <span class="fu">=</span> simplify (a <span class="fu">*</span> b)</a>
<a class="sourceLine" id="cb53-8" data-line-number="8">    <span class="kw">in</span> <span class="kw">if</span> simplified <span class="fu">==</span> (a <span class="fu">*</span> b)</a>
<a class="sourceLine" id="cb53-9" data-line-number="9">       <span class="kw">then</span> a <span class="fu">*</span> integrateEx b v <span class="dv">0</span> <span class="fu">-</span> integrateEx (derive a <span class="fu">*</span> b) v <span class="dv">0</span> <span class="fu">+</span> <span class="dt">Const</span> c</a>
<a class="sourceLine" id="cb53-10" data-line-number="10">       <span class="kw">else</span> integrateEx simplified v c</a>
<a class="sourceLine" id="cb53-11" data-line-number="11">integrateEx (a <span class="fu">:/</span> b) v c <span class="fu">=</span></a>
<a class="sourceLine" id="cb53-12" data-line-number="12">    <span class="kw">let</span> simplified <span class="fu">=</span> simplify (a <span class="fu">/</span> b)</a>
<a class="sourceLine" id="cb53-13" data-line-number="13">    <span class="kw">in</span> <span class="kw">if</span> simplified <span class="fu">==</span> (a <span class="fu">/</span> b)</a>
<a class="sourceLine" id="cb53-14" data-line-number="14">       <span class="kw">then</span> <span class="kw">let</span> _A <span class="fu">=</span> integrateEx a v <span class="dv">0</span></a>
<a class="sourceLine" id="cb53-15" data-line-number="15">            <span class="kw">in</span> _A <span class="fu">/</span> b <span class="fu">+</span> integrateEx (_A <span class="fu">*</span> (derive b <span class="fu">/</span> (b<span class="fu">^</span><span class="dv">2</span>))) v <span class="dv">0</span> <span class="fu">+</span> <span class="dt">Const</span> c</a>
<a class="sourceLine" id="cb53-16" data-line-number="16">       <span class="kw">else</span> integrateEx simplified v c</a>
<a class="sourceLine" id="cb53-17" data-line-number="17">integrateEx e<span class="fu">@</span>(f <span class="fu">:$</span> <span class="dt">Const</span> a) v c <span class="fu">=</span> e <span class="fu">*</span> <span class="dt">Var</span> v <span class="fu">+</span> <span class="dt">Const</span> c</a>
<a class="sourceLine" id="cb53-18" data-line-number="18">integrateEx e<span class="fu">@</span>(f <span class="fu">:$</span> <span class="dt">Var</span> u) v c <span class="fu">|</span> v <span class="fu">==</span> u    <span class="fu">=</span> integrate f c <span class="fu">:$</span> <span class="dt">Var</span> v</a>
<a class="sourceLine" id="cb53-19" data-line-number="19">                                 <span class="fu">|</span> otherwise <span class="fu">=</span> e <span class="fu">*</span> <span class="dt">Var</span> v <span class="fu">+</span> <span class="dt">Const</span> c</a>
<a class="sourceLine" id="cb53-20" data-line-number="20">integrateEx _ _ _ <span class="fu">=</span> undefined</a></code></pre></div>
<p>And we’re done with our DSL of calculus!</p>
<h2 id="todo-proofverification">TODO: Proof/verification</h2>
<p>proof and/or tests go here</p>
<h2 id="todo-examples">TODO: Examples</h2>
<p>they go here</p>
<p>TODO: Move to after differentiation and integration and all that. Begin by just doing all syntactical stuff, and then end the chapter with evaluation, visualization, and testing. The value of evaluation ———————————————————————-</p>
<p>What comes after construction of function expressions? Well, using them of course!</p>
<p>One way of using a function expression is to evaluate it, and use it just as you would a normal Haskell function. To do this, we need to write an evaluator.</p>
<p>An evaluator simply takes a syntactic representation and returns the semantic value, i.e. <code>eval :: SYNTAX -&gt; SEMANTICS</code>.</p>
<p>In the case of our calculus language:</p>
<div class="sourceCode" id="cb54"><pre class="sourceCode literate haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb54-1" data-line-number="1"><span class="ot">eval ::</span> <span class="dt">FunExpr</span> <span class="ot">-&gt;</span> (<span class="dt">RealNum</span> <span class="ot">-&gt;</span> <span class="dt">RealNum</span>)</a></code></pre></div>
<p>To then evaluate a <code>FunExpr</code> is not very complicated. The elementary functions and the <code>Id</code> function are simply substituted for their Haskell counterparts.</p>
<div class="sourceCode" id="cb55"><pre class="sourceCode literate haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb55-1" data-line-number="1">eval <span class="dt">Exp</span> <span class="fu">=</span> exp</a>
<a class="sourceLine" id="cb55-2" data-line-number="2">eval <span class="dt">Log</span> <span class="fu">=</span> log</a>
<a class="sourceLine" id="cb55-3" data-line-number="3">eval <span class="dt">Sin</span> <span class="fu">=</span> sin</a>
<a class="sourceLine" id="cb55-4" data-line-number="4">eval <span class="dt">Cos</span> <span class="fu">=</span> cos</a>
<a class="sourceLine" id="cb55-5" data-line-number="5">eval <span class="dt">Asin</span> <span class="fu">=</span> asin</a>
<a class="sourceLine" id="cb55-6" data-line-number="6">eval <span class="dt">Acos</span> <span class="fu">=</span> acos</a>
<a class="sourceLine" id="cb55-7" data-line-number="7">eval <span class="dt">Id</span> <span class="fu">=</span> id</a></code></pre></div>
<p><code>Const</code> is evaluated according to the definition <span class="math inline">\(const(c) = x \mapsto c\)</span></p>
<div class="sourceCode" id="cb56"><pre class="sourceCode literate haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb56-1" data-line-number="1">eval (<span class="dt">Const</span> c) <span class="fu">=</span> \x <span class="ot">-&gt;</span> c</a></code></pre></div>
<p>How to evaluate arithmetic operations on functions may not be as obvious, but we just implement them as they were defined earlier in the chapter.</p>
<div class="sourceCode" id="cb57"><pre class="sourceCode literate haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb57-1" data-line-number="1">eval (f <span class="fu">:+</span> g) <span class="fu">=</span> \x <span class="ot">-&gt;</span> (eval f x <span class="fu">+</span> eval g x)</a>
<a class="sourceLine" id="cb57-2" data-line-number="2">eval (f <span class="fu">:-</span> g) <span class="fu">=</span> \x <span class="ot">-&gt;</span> (eval f x <span class="fu">-</span> eval g x)</a>
<a class="sourceLine" id="cb57-3" data-line-number="3">eval (f <span class="fu">:*</span> g) <span class="fu">=</span> \x <span class="ot">-&gt;</span> (eval f x <span class="fu">*</span> eval g x)</a>
<a class="sourceLine" id="cb57-4" data-line-number="4">eval (f <span class="fu">:/</span> g) <span class="fu">=</span> \x <span class="ot">-&gt;</span> (eval f x <span class="fu">/</span> eval g x)</a></code></pre></div>
<p>Function composition is similarly evaluated according to the earlier definition</p>
<div class="sourceCode" id="cb58"><pre class="sourceCode literate haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb58-1" data-line-number="1">eval (f <span class="fu">:.</span> g) <span class="fu">=</span> \x <span class="ot">-&gt;</span> eval f (eval g x)</a></code></pre></div>
<p>TODO: these bad bois</p>
<div class="sourceCode" id="cb59"><pre class="sourceCode literate haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb59-1" data-line-number="1">eval (<span class="dt">Delta</span> h f) <span class="fu">=</span> undefined</a>
<a class="sourceLine" id="cb59-2" data-line-number="2"><span class="co">-- eval env (Delta x) = LambdaVal &quot;_a&quot; (Lambda &quot;_b&quot; ((x&#39; :$ &quot;_b&quot;) - (x&#39; :$ &quot;_a&quot;)))</span></a>
<a class="sourceLine" id="cb59-3" data-line-number="3"><span class="co">--   where x&#39; = subst env x</span></a>
<a class="sourceLine" id="cb59-4" data-line-number="4">eval (<span class="dt">D</span> f) <span class="fu">=</span> undefined</a>
<a class="sourceLine" id="cb59-5" data-line-number="5"><span class="co">-- eval env (D f) = eval env (simplify (derive f))</span></a>
<a class="sourceLine" id="cb59-6" data-line-number="6">eval (<span class="dt">I</span> c f) <span class="fu">=</span> undefined</a></code></pre></div>
<h2 id="todo-applying-our-dsl-to-solve-physics-problems">TODO: Applying our DSL to solve physics problems!</h2>
<p>Mostly problems regarding position, velocity, acceleration, time.</p>
<p>Average FOO vs. Instantaneous FOO – Differences vs Derivatives.</p>
<p>Integrating to get rid of /t:s.</p>
<p>cool stuff here in general.</p>
<p>Also, many pretty pictores</p>
<div class="sourceCode" id="cb60"><pre class="sourceCode literate haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb60-1" data-line-number="1"><span class="fu">-</span>}</a></code></pre></div>

    </main>

    <footer>
      <nav>
        <span>Previous: <a href="../Vectors/Vector.html">Vector</a></span>
        <a href="../index.html">Table of contents</a>
        <span>Next: <a href="../Calculus/Syntax Tree.html">Syntax Tree</a></span>
      </nav>
      Licensed under the GPL by the Kandidatboisen (2018)
    </footer>
  </body>
</html>
